
# File: .\main.py
if __name__ == "__main__":
    from GUI.GUI_class import GUI
    import streamlit as st

    st.set_page_config(
        page_title="Smipps",
        page_icon="ðŸ–©",
        layout="wide"
     )
    
    GUI()


    


    


# File: .\test.py
import os

def gather_python_code(root_directory, output_file):
    with open(output_file, 'w') as outfile:
        for subdir, dirs, files in os.walk(root_directory):
            for file in files:
                if file.endswith('.py'):
                    file_path = os.path.join(subdir, file)
                    outfile.write(f"\n# File: {file_path}\n")
                    with open(file_path, 'r') as infile:
                        outfile.write(infile.read())
                        outfile.write("\n\n")

# Usage
root_dir = '.'  # Current directory
output_file = 'project_code_appendix.txt'  # Output file in the current directory
gather_python_code(root_dir, output_file)


# File: .\Data\dataProcessing.py
import Data.getData as get
import streamlit as st
from pandas import DataFrame

def get_field_list_inc_No_field_chosen():
    fieldnames = get.fieldNames()

    def custom_sort_key(s, char_map):
        return ''.join(char_map.get(c, c) for c in s)

    def locale_aware_sort(arr):
        # Map special characters to a representation for sorting
        char_map = {'Ã˜': 'Oz', 'Ã†': 'Ae', 'Ã…': 'Aa'}

        # Sort using the custom sort key
        arr.sort(key=lambda s: custom_sort_key(s, char_map))

    locale_aware_sort(fieldnames)
    fieldnames.insert(0, 'No field chosen')
    return fieldnames
               
def estimatedReservoirPressure(TVD: float) -> float:
    """
    takes in discoveryWell and returns the estimated reservoir pressure in bara. estimate: pressure increases with 1.1 bar for every 10 m of depth

    """
    pressure = TVD/10 * 1.1
    return pressure

def addActualProdYtoDF(field: str, df: DataFrame,  adjustLength = True) ->DataFrame:
    gas, NGL, oil, cond, Oe, w = get.CSVProductionYearly(field)
    if adjustLength == True: #should i remove 0 production
        while len(df) != len(gas):
            gas.append(0)
        while len(df) != len(NGL):
            NGL.append(0)
        while len(df) != len(oil):
            oil.append(0)
        while len(df) != len(cond):
            cond.append(0)
        while len(df) != len(Oe):
            Oe.append(0)
        while len(df) != len(w):
            w.append(0)
    gas = [i*10**9/365 for i in gas] #prfPrdGasNetBillSm3
    df = df.assign(gasSM3perday=gas)
    NGL = [i*10**6/365 for i in NGL] #prfPrdOilNetMillSm3
    oil = [i*10**6/365 for i in oil] #prfPrdCondensateNetMillSm3
    cond = [i*10**6/365 for i in cond] #prfPrdOeNetMillSm3
    Oe = [i*10**6/365 for i in Oe] #prfPrdOeNetMillSm3
    w = [i*10**6/365 for i in w] #prfPrdProducedWaterInFieldMillSm3
    df = df.assign(NGLSM3perday=NGL)
    df = df.assign(oilSM3perday=oil)
    df = df.assign(condensateSM3perday=cond)
    df = df.assign(OilEquivalentsSM3perday=Oe)
    df = df.assign(WaterSM3perday=w)
    return df

def yearly_produced_DF(field: str, df: DataFrame) ->DataFrame:
    import streamlit as st
    gas, NGL, oil, cond, Oe, w = get.CSVProductionYearly(field)
    gas = [i*10**9 for i in gas] #prfPrdGasNetBillSm3
    NGL = [i*10**6 for i in NGL] #prfPrdOilNetMillSm3
    oil = [i*10**6 for i in oil] #prfPrdCondensateNetMillSm3
    cond = [i*10**6 for i in cond] #prfPrdOeNetMillSm3
    Oe = [i*10**6 for i in Oe] #prfPrdOeNetMillSm3
    w = [i*10**6 for i in w] #prfPrdProducedWaterInFieldMillSm3
    df = df.assign(gasSM3Yearly=gas)
    df = df.assign(NGLSM3Yearly=NGL)
    df = df.assign(oilSM3Yearly=oil)
    df = df.assign(condensateSM3Yearly=cond)
    df = df.assign(OilEquivalentsSM3Yearly=Oe)
    df = df.assign(WaterSM3Yearly=w)
    return df

def monthly_produced_DF(field: str, df: DataFrame) ->DataFrame:
    import streamlit as st
    gas, NGL, oil, cond, Oe, w = get.CSVProductionMonthly(field)
    gas = [i*10**9 for i in gas] #prfPrdGasNetBillSm3
    NGL = [i*10**6 for i in NGL] #prfPrdOilNetMillSm3
    oil = [i*10**6 for i in oil] #prfPrdCondensateNetMillSm3
    cond = [i*10**6 for i in cond] #prfPrdOeNetMillSm3
    Oe = [i*10**6 for i in Oe] #prfPrdOeNetMillSm3
    w = [i*10**6 for i in w] #prfPrdProducedWaterInFieldMillSm3
    df = df.assign(gasSM3Monthly=gas)
    df = df.assign(gasSM3Monthly=gas)
    df = df.assign(NGLSM3Monthly=NGL)
    df = df.assign(oilSM3Monthly=oil)
    df = df.assign(condensateSM3Monthly=cond)
    df = df.assign(OilEquivalentsSM3Monthly=Oe)
    df = df.assign(WaterSM3Monthly=w)
    return df

def addProducedYears(field: str, df: DataFrame, adjustLength=True) -> DataFrame:
    try:
        sY = min(get.CSVProducedYears(field))
        years = [sY]

        if adjustLength:
            i = 1
            while len(years) < len(df.iloc[:, 0]):
                years.append(sY + i)
                i += 1

        df.index = years
        return df
    except Exception as e:
        st.warning(f"Field has likely not produced anything yet. Could not get the produced years due to the following error: {e}.")
        return df

def addProducedMonths(field: str, df: DataFrame) -> DataFrame:
    try:
        dates = []
        years, months = get.CSVProducedMonths(field)
        for year, month in zip(years, months):
            date = f"{month}:{year}"  
            dates.append(date)
        
        df.index = dates
        return df
    except Exception as e:
        st.warning(f"Field has likely not produced anything yet. Could not get the produced year-months due to the following error: {e}.")
        return df




    


    


# File: .\Data\getData.py
import pandas as pd
import zipfile
import wget
import os
import requests
import streamlit as st
import time
from Data.Storage.Cache import delete_files
import Data.Storage.Cache as c
data_storage_folder = os.path.join(os.getcwd(), 'Data', 'Storage')

def ZiptoDF(zipname='fldArea.zip', zipFileUrl='https://factpages.npd.no/downloads/csv/fldArea.zip'):
    zip_file_path = os.path.join(data_storage_folder, zipname)
    if os.path.exists(zip_file_path):
        zf = zipfile.ZipFile(zip_file_path)
    else:
        response = requests.get(zipFileUrl)
        if response.status_code == 200:
            wget.download(zipFileUrl, out=zip_file_path)            
            zf = zipfile.ZipFile(zip_file_path)
        else:
            st.write(f'Failed to get data from NPD, status code: {response.status_code}')
    df = pd.read_csv(zf.open(zf.namelist()[0]), low_memory=False)
    zf.close()
    return df

def fieldNames():
    fldData = c.CacheDF(df=ZiptoDF(), key='fldArea')
    field_names = list(fldData['fldName'])
    return field_names

def polygon_coordinates(fieldName):
    p = c.CacheDF(df=ZiptoDF(), key='fldArea')
    p.drop(p[p['fldName'] != fieldName].index, inplace=True)
    fldAreaGeometryWKT = p['fldAreaGeometryWKT'].iloc[0]
    return fldAreaGeometryWKT

def wlbPoint_field_sorted(fieldName):
    p = c.CacheDF(df = ZiptoDF(zipname = 'wlbPoint.zip', zipFileUrl = 'https://factpages.npd.no/downloads/csv/wlbPoint.zip'), key = 'wlbPoint')
    p.drop(p[p['wlbField'] != fieldName].index, inplace=True)
    return p

def producing_wlb(fieldName):
    p = wlbPoint_field_sorted(fieldName)
    p.drop(p[p['wlbStatus'] != 'PRODUCING'].index, inplace=True)
    return p

def injecting_wlb(fieldName):
    p = wlbPoint_field_sorted(fieldName)
    p.drop(p[p['wlbStatus'] != 'INJECTING'].index, inplace=True)
    return p

def PA_wlb(fieldName):
    p = wlbPoint_field_sorted(fieldName)
    p.drop(p[p['wlbStatus'] != 'P&A'].index, inplace=True)
    return p

def closed_wlb(fieldName):
    p = wlbPoint_field_sorted(fieldName)
    p.drop(p[p['wlbStatus'] != 'CLOSED'].index, inplace=True)
    return p

def junked_wlb(fieldName):
    p = wlbPoint_field_sorted(fieldName)
    p.drop(p[p['wlbStatus'] != 'junked'].index, inplace=True)
    return p

def CSVProductionMonthly(fieldName: str):
    if c.checkKeyCached('monthlyProduction'):
        p = c.CacheDF(df = None, key ='monthlyProduction')  
    else:
        csvURL = 'https://hotell.difi.no/download/npd/field/production-monthly-by-field'
        response = requests.get(csvURL)
        if response.status_code == 200:
            data_to_store = c.csvURLtoDF(csvURL)
            p = c.CacheDF(df = data_to_store, key ='monthlyProduction')  
        else:
            st.write(f'Failed to get NPD data using digitaliseringsdirektoratets API, status code: {response.status_code}')
    p.drop(p[p['prfInformationCarrier'] != fieldName.upper()].index, inplace=True)
    gas = p['prfPrdGasNetBillSm3'].tolist()
    NGL = p['prfPrdNGLNetMillSm3'].tolist()
    oil = p['prfPrdOilNetMillSm3'].tolist()
    cond = p['prfPrdCondensateNetMillSm3'].tolist()
    Oe = p['prfPrdOeNetMillSm3'].tolist()
    w = p['prfPrdProducedWaterInFieldMillSm3'].tolist()
    return gas, NGL, oil, cond, Oe, w

def CSVProductionYearly(field: str):
    if c.checkKeyinDict('yearlyProduction'):
        p = c.CacheDF(df = None, key = 'yearlyProduction')
    else:
        csvURL = 'https://hotell.difi.no/download/npd/field/production-yearly-by-field'
        response = requests.get(csvURL)
        if response.status_code == 200:
            data_to_store = c.csvURLtoDF(csvURL)
            p = c.CacheDF(df = data_to_store, key = 'yearlyProduction')
        else:
            st.write(f'Failed to get NPD data using digitaliseringsdirektoratets API, status code: {response.status_code}')
    p.drop(p[p['prfInformationCarrier'] != field.upper()].index, inplace=True)
    gas = p['prfPrdGasNetBillSm3'].tolist()
    NGL = p['prfPrdNGLNetMillSm3'].tolist()
    oil = p['prfPrdOilNetMillSm3'].tolist()
    cond = p['prfPrdCondensateNetMillSm3'].tolist()
    Oe = p['prfPrdOeNetMillSm3'].tolist()
    w = p['prfPrdProducedWaterInFieldMillSm3'].tolist()
    return gas, NGL, oil, cond, Oe, w

def CSVProducedYears(fieldName: str) -> list:
    if c.checkKeyinDict('yearlyProduction'):
        p = c.CacheDF(df = None, key = 'yearlyProduction')
    else:
        csvURL = 'https://hotell.difi.no/download/npd/field/production-yearly-by-field'
        response = requests.get(csvURL)
        if response.status_code == 200:
            data_to_store = c.csvURLtoDF(csvURL)
            p = c.CacheDF(df = data_to_store, key = 'yearlyProduction')
        else:
            st.write(f'Failed to get NPD data using digitaliseringsdirektoratets API, status code: {response.status_code}')
    p.drop(p[p['prfInformationCarrier'] != fieldName.upper()].index, inplace=True)
    years = p['prfYear'].tolist()
    return years

def CSVProducedMonths(fieldName: str) -> list:
    if c.checkKeyinDict('monthlyProduction'):
        p = c.CacheDF(df = None, key = 'monthlyProduction')
    else:
        csvURL = 'https://hotell.difi.no/download/npd/field/production-monthly-by-field'
        response = requests.get(csvURL)
        if response.status_code == 200:
            data_to_store = c.csvURLtoDF(csvURL)
            p = c.CacheDF(df = data_to_store, key = 'monthlyProduction')
        else:
            st.write(f'Failed to get NPD data using digitaliseringsdirektoratets API, status code: {response.status_code}')
    p.drop(p[p['prfInformationCarrier'] != fieldName.upper()].index, inplace=True)
    years = p['prfYear'].tolist()
    months = p['prfMonth'].tolist()
    return years, months

def deleteAndLoadNewDataFromNPD():
    zipfile_URLs = [
        'https://factpages.npd.no/downloads/csv/fldArea.zip',
        'https://factpages.npd.no/downloads/csv/wlbPoint.zip', 
        'https://hotell.difi.no/download/npd/field/reserves?download',
        'https://hotell.difi.no/download/npd/field/production-monthly-by-field',
        'https://hotell.difi.no/download/npd/field/production-yearly-by-field'
    ]  
    try:
        response_list = [requests.get(url).status_code for url in zipfile_URLs]
        if all(status == 200 for status in response_list):
            delete_files()
            ZiptoDF()
            ZiptoDF(zipname = 'wlbPoint.zip', zipFileUrl = 'https://factpages.npd.no/downloads/csv/wlbPoint.zip')
        else:
            raise Exception("Not all NPD resources are available. Visit NPD for further information.")
    except requests.exceptions.RequestException as e:
        my = st.warning(f"Request error: {e}")
        time.sleep(5)
        my.empty()
    except Exception as e:
        my2 = st.warning(f"Error: {e}")
        time.sleep(5)
        my2.empty()

def CSV_reserves():
    if c.checkKeyinDict('reserves'):
        p = c.CacheDF(df = None, key = 'reserves')
    else:
        csvURL = 'https://hotell.difi.no/download/npd/field/reserves?download'
        response = requests.get(csvURL)
        if response.status_code == 200:
            data_to_store = c.csvURLtoDF(csvURL)
            p = c.CacheDF(df = data_to_store, key = 'reserves')
        else:
            st.warning(f'Failed to get NPD data using digitaliseringsdirektoratets resources, status code: {response.status_code}')
    return p

def Temp(fieldName):
    if c.checkKeyinDict('wlbPoint'):
        p = c.CacheDF(df = None, key = 'wlbPoint')
    else:
        data_to_store = ZiptoDF(zipname = 'wlbPoint.zip', zipFileUrl = 'https://factpages.npd.no/downloads/csv/wlbPoint.zip')
        p = c.CacheDF(df = data_to_store, key = 'wlbPoint')
    p.drop(p[p['wlbField'] != fieldName.upper()].index, inplace=True)
    mean_temp = p["wlbBottomHoleTemperature"].mean()
    return round(mean_temp,1)

def IGIP(fieldName):
    reserves = CSV_reserves()
    reserves.drop(reserves[reserves['fldName'] != fieldName.upper()].index, inplace=True)
    reserves = reserves.reset_index(drop = True)
    fldRecoverableGas = reserves.loc[0,'fldRecoverableGas']
    fldRemainingGas = reserves.loc[0, 'fldRemainingGas']
    initial_GIP = fldRecoverableGas + fldRemainingGas
    return initial_GIP*1e9

def gas_molecular_weight(fieldName):
    #default value used. could not find data at NPD
    return 16 #g/mol 

def initial_reservoir_pressure(fieldName):
    #default value used, could not find data at NPD
    return 276 #reservoir pressure bara




# File: .\Data\ManualData.py
def manualData() -> list:
    qFieldTarget = 20e6 #target rate sm3/d
    PRi = 276 #reservoir pressure bara
    IGIP = 270e9 #Initial gas in place
    abandonmentRate = 5e6 
    TR = 92 #reservoir temperature [C]
    gasMolecularWeight = 16 #[g/mol]
    C_t = 40288.1959178652#Ct, Tubing flow coefficient (2100 MDx0.15 ID  m)
    S = 0.155#tubing elevation coefficient
    C_FL = 283126.866184114#flowline coefficient from template-PLEM (5000x0.355  ID m)
    C_PL = 275064.392725841#CPL Pipeline coefficient from PLEM-Shore (158600x0.68  ID m)
    P_sep =30 #seperator pressure in bara
    N_temp = 3 #number of templates
    NWellsPerTemplate = 3 #number of wells per template
    C_R = 1000 #inflow backpressure coefficient
    n = 1 #Inflow backpressure exponent
    upTime = 365
    list = [qFieldTarget, PRi, abandonmentRate, TR, gasMolecularWeight, C_R, n, N_temp, NWellsPerTemplate, upTime, C_t, S, C_FL, C_PL, P_sep, IGIP]
    return list

def manualData_RP() -> list:
    PRi = 276 #reservoir pressure bara
    IGIP = 270e9 #Initial gas in place   
    TR = 92 #reservoir temperature [C]
    gasMolecularWeight = 16 #[g/mol]
    list = [PRi, TR, gasMolecularWeight, IGIP]
    return list







# File: .\Data\StreamlitUpload.py
import streamlit as st
import pandas as pd
from io import StringIO
def upload(text ='Upload a file')->pd.DataFrame:
    uploaded_file = st.file_uploader(text)
    if uploaded_file is not None:
        # To read file as bytes:
        bytes_data = uploaded_file.getvalue()
        st.write(bytes_data)

        # To convert to a string based IO:
        stringio = StringIO(uploaded_file.getvalue().decode("utf-8"))
        st.write(stringio)

        # To read file as string:
        string_data = stringio.read()
        st.write(string_data)

        # Can be used wherever a "file-like" object is accepted:
        dataframe = pd.read_csv(uploaded_file)
        return dataframe



# File: .\Data\__init__.py



# File: .\Data\Storage\Cache.py
import os
import pandas as pd
import shelve
import streamlit as st
data_storage_folder = os.path.join(os.getcwd(), 'Data', 'Storage')
cacheDF = {}

def csvURLtoDF(csvURL: str) ->pd.DataFrame:
    df = pd.read_csv((csvURL), sep = ";", low_memory=False)
    return df

def CacheDF(df, key):
    if checkKeyinDict(key):
        return loadDict(key)
    else:
        dumpDict(df, key)
        return loadDict(key)
        
def checkKeyCached(key):
        if key in cacheDF:
            return True
        else:
            return False
    
def dumpDict(data, name):
    with shelve.open(os.path.join(data_storage_folder, 'savedDictionary')) as d:
        d[name] = data

def checkKeyinDict(key):
    with shelve.open(os.path.join(data_storage_folder, 'savedDictionary')) as d:
        return key in d

def loadDict(key):
    with shelve.open(os.path.join(data_storage_folder, 'savedDictionary')) as d:
        if key not in d:
            st.warning('An error has accured')
        else:
            loaded_data = d[key]
            return loaded_data
    
import streamlit as st
class SessionState:
    def __init__(self, **kwargs):
        for key, val in kwargs.items():
            setattr(self, key, val)

    @staticmethod
    def get(id, **kwargs):
        if not hasattr(st, '_global_session_states'):
            st._global_session_states = {}
        if id not in st._global_session_states:
            st._global_session_states[id] = SessionState(**kwargs)
        return st._global_session_states[id]

    def delete(id):
        if hasattr(st, '_global_session_states') and id in st._global_session_states:
            del st._global_session_states[id]

    def append(id, key, value):
        if not hasattr(st, '_global_session_states'):
            st._global_session_states = {}
        # Retrieve the specific session state using the provided ID
        session_state = st._global_session_states.get(id)

        # Append the value to the list corresponding to the key
        current_list = getattr(session_state, key, [])
        current_list.append(value)     
        setattr(session_state, key, current_list)

def delete_files():
    files_to_delete = [
        "savedDictionary.bak",
        "savedDictionary.dat",
        "savedDictionary.dir",
        "wlbPoint.zip",
        "fldArea.zip"
    ]
    
    for file in files_to_delete:
        file_path = os.path.join(data_storage_folder, file)
        if os.path.exists(file_path):
            os.remove(file_path)

def clear_state(state:SessionState):
    state.result = []
    state.method = []
    state.precision = []
    state.field = []

def clear_state2(state:SessionState):
    state.result = []
    state.time_frame = []
    state.production_data = []
    state.field = []

    


# File: .\Data\Storage\__init__.py



# File: .\Equations\DryGasFlowEquations.py
def IPRqg(C_R: float, n:float, p_R:float, p_wf:float) -> float:
    """
    Returns gas rate bottomhole. 
    C_R = backpressure coefficient [sm^3/bar^(2*n)], 
    n = Backpressure exponent (typically assumed 1),
    p_R = reservoir pressure [bar],
    p_wf = pressure bottomhole well, wellflow [bar].
    """
    IPRqg = C_R*(p_R**2-p_wf**2)**n
    return IPRqg

def IPRpwf(C_R:float, n:float, p_R:float, q_g:float) -> float:
    """
    Returns pressure bottomhole. 
    C_R = backpressure coefficient [sm^3/bar^(2*n)], 
    n = Backpressure exponent (typically assumed 1),
    p_R = reservoir pressure [bar],
    p_wf = pressure bottomhole well, wellflow [bar].
    """
    IPRpwf=(p_R**2-(q_g/C_R)**(1/n))**0.5
    return IPRpwf

def IPR_PR(C_R:float, n:float, p_wf:float, q_g:float) -> float:
    """
    Returns reservoir pressure. Equation based on IPR equation solved for P_R with Pwf as input
    pressure upstream wf (reservoir pressure) (moving counter stream from 2 to 1).
.
    C_R = backpressure coefficient [sm^3/bar^(2*n)], 
    n = Backpressure exponent (typically assumed 1),
    p_wf = pressure bottomhole well, wellflow [bar].
    p_R = reservoir pressure [bar],
    """
    P_R=(p_wf**2+(q_g/C_R)**(1/n))**0.5
    return P_R

def Tubingqg(C_T:float, s:float, p1:float, p2:float) -> float:
    import math
    """
    Returns gas rate tubingline.
    C_T = tubing coefficient [sm3/bar],
    p1 = pressure upstream the tube [bar],
    p2 = pressure downstream the tube [bar],
    s = tubing elevation coefficient.
    """
    Tubingqg = C_T*(p1**2/(math.e)**s-p2**2)**0.5
    return Tubingqg

def Tubingp1(C_T:float, s:float, p2:float, q_g:float) -> float:
    import math
    """
    Returns pressure upstream tubingline (moving counter stream from 2 to 1).
    C_T = tubing coefficient [sm3/bar],
    p2 = pressure downstream the tube [bar],
    s = tubing elevation coefficient,
    """
    Tubingp1 = (math.e)**(s/2)*(p2**2+(q_g/C_T)**2)**0.5
    return Tubingp1

def Tubingp2(C_T:float, s:float, p1:float, q_g:float) -> float:
    import math
    import warnings
    """
    Returns pressure downstream tubingline (moving with stream from 1 to 2). 
    C_T = tubing coefficient [sm3/bar],
    p1 = pressure upstream the tube [bar],
    s = tubing elevation coefficient.
    """
    import warnings
    warnings.filterwarnings("ignore", message="invalid value encountered in sqrt") #tryging to root negative root number warning
    Tubingp2 = (p1**2/math.e**s-(q_g/C_T)**2)**0.5 
    return Tubingp2

def Lineqg(C_FL:float, p1:float, p2:float) -> float:
    """
    Returns gasrate.
    Assumes horizontal line,
    p1 = pressure upstream,
    p2 = pressure downstream.
    C_FL = flowline coefficient
    """
    Lineqg = C_FL*(p1**2-p2**2)**0.5
    return Lineqg

def Linep1(C_FL:float, p2:float, q_g:float) -> float:
    """
    Returns pressure upstream line (moving counter stream from 2 to 1).
    Assumes horizontal line,
    C_FL = flowline coefficient,
    p2 = pressure downstream.
    """
    Linep1 = (p2**2 + (q_g/C_FL)**2)**0.5
    return Linep1

def Linep2(C_FL:float, p1:float, q_g:float) -> float:
    """
    Returns pressure downstream line (moving with stream from 1 to 2).
    Assumes horizontal line,
    C_FL = flowline coefficient,
    p1 = pressure upstream.
    """
    Linep2= (p1**2-(q_g/C_FL)**2)**0.5
    return Linep2




# File: .\Equations\MBgastank_PR.py
def MBgastank_PR(PRi, Zi, ZR, RF):
    """
    Simple reservoir model. Returns reservoir pressure at year i based on: 
    ZR = Z factor at year i,
    Pi = initial reservoir pressure year 0,
    Zi = intial Z factor year 0,
    RF = recovery factor at year i.
    
    """
    MBgastank_PR = (ZR * (PRi/Zi)*(1-RF))
    return MBgastank_PR



# File: .\Equations\pWfMinEstimation.py
from Equations.DryGasFlowEquations import Linep1, Tubingp1
def pWfMinEstimation(C_t: float, S: float, C_FL: float, C_PL:float , fieldRate: float, p_sep: float, N_temp: int, NWellsPerTemplate: int)->float:
    """
    Returns a minimum estimation of bottomhole pressure based on the following data. Assumes pressure at wellhead equal to pressure at template.  
    C_t = tubing coefficient [sm3/bar],
    S = tubing elevation coefficient,
    C_FL = flowline coefficient,
    C_PL = Pipeline coefficient,
    P_sep = Pressure at separator,
    N_temp = Number of templates,
    NWellsPerTemplate = Number of wells per template,
    Field rate.
    """     
    p_plem = Linep1(C_PL, p_sep , fieldRate) #pressure pipeline entry module  
    q_temp = fieldRate / N_temp #gasrate per template
    p_temp = Linep1(C_FL, p_plem, q_temp) #pressure at template
    p_wh = p_temp #assuming that pressure at wellhead is equal to pressure at the template 
    q_well = q_temp / NWellsPerTemplate
    p_wf = Tubingp1(C_t, S, p_wh, q_well)
    return p_wf 


# File: .\Equations\RF.py
def RF(Gp, IGIP):
    """
    Returns recovery factor based on:
    Gp = total gass offtake,
    IGIP = initial gas in place
    """
    RF = Gp/IGIP
    return RF




# File: .\Equations\ZfacStanding.py
import math 
def ZfacStanding(p1: float, T1: float, gasMolecularWeight: float) ->float:
    """
    Returns Z-factor based on Hall&Yarborough equation fitted to Standing-Katz Chart. Use psia and Â°F or bara and Â°C.
    p1 = pressure [bara],
    T1 = Temperature [Â°C],
    GasMolecularWeight = molecular weight of the gas at standard conditions (air=1)
    """
        
    #Calculating Specific Gravity (air = 1) Yg
    massAir = 28.967 #g/mol (could use 28.967 instead)
    Yg = gasMolecularWeight/massAir
    
    
    #Calculating pseudocriticaltemperature and pressure
    
    #Suttons suggestion for correlations for hydrocarbon gas mixtures
    Tpc = 169.2 + 349.5 * Yg - 74 * Yg**2
    Ppc = 756.8 - 131 * Yg - 3.6*Yg**2

    T = 9/5 *T1 + 32
    p = 14.5038*p1
    
    #Calculating pseudo reduced properties
    Tpr = (T + 460) / Tpc
    Ppr = p / Ppc
    T = 1 / Tpr
    A = 0.06125 * T * (math.e)**(-1.2 * (1 - T) ** 2)
    Y = 0.001
    i = 0
    F=1
    
    #Finding the Z factor by looping. Adding constraint that the loop should only run 1000 iterations in case it doesnt converge
    
    while abs(F) > 0.00000001 and i < 1000: 
        fy = -A * Ppr + (Y + Y**2 + Y**3 - Y ** 4) / ((1 - Y) ** 3) - (14.76 * T - 9.76 * T**2 + 4.58 * T**3) * Y**2 + (90.7 * T - 242.2 * T**2 + 42.4 * T**3) * Y**(2.18 + 2.82 * T)
        
        dfY = (1 + 4 * Y + 4 * Y**2 - 4 * Y**3 + Y**4) / ((1 - Y) ** 4) - (29.52 * T - 19.52 * T**2 + 9.16 * T** 3) * Y + (2.18 + 2.82 * T) * (90.7 * T - 242.2 * T ** 2 + 42.4 * T**3) * Y**(1.18 + 2.82 * T)
        Y = Y - fy / dfY
        F = fy / dfY
        i+=1
        
    Z = A * Ppr / Y
    ZfacStanding = Z
    return ZfacStanding




# File: .\Equations\__init__.py



# File: .\GUI\GUI_class.py
import streamlit as st
import GUI.GUI_functions as display
import time
import Data.getData as get
import os
from Data.dataProcessing import get_field_list_inc_No_field_chosen
from Data.ManualData import manualData_RP
fieldnames = get_field_list_inc_No_field_chosen()
class GUI(): 
    def __init__(self):
        col1, col2, col3, col4, col5 = st.columns(5)
        with col5:
            load = st.button('Load New Data from NPD',  'NPD')
            if load:
                from Data.getData import deleteAndLoadNewDataFromNPD
                deleteAndLoadNewDataFromNPD()
                timestamp = time.ctime()
                alert00 = st.warning('Data downloaded from NPD ' + timestamp)
                time.sleep(5)
                alert00.empty() 
        opt = display.dropdown(label = 'What do you want to use the application for?',options = ['NO OPTION CHOSEN', 'FIELD DEVELOPMENT', 'RESERVOIR PRESSURE FROM PRODUCTION DATA', 'NPD DATA'], labelVisibility='visible')   
        if opt == "NO OPTION CHOSEN":
            st.title('Simulation and Modeling of Integrated Petroleum Production Systems')
            st.write(" ")
            st.write(" ")
            col1, col2 = st.columns(2)
            with col1:
                my_path = os.path.join('Data', 'Storage', 'Morten_front_page.png')
                st.image(my_path)
            with col2:
                on_information = st.toggle("Show me more information on how to use the application", value=False, label_visibility="visible")
                if on_information:
                    st.write(
                             """The application is connected to NPD. Data can automatically be pulled from NPDs open data sources, 
                            before being used in the application. The data includes field, well and production data. The data is stored
                            in the application. The button in the top right corner <Load New Data from NPD> deletes the stored data, and fetches the latest data 
                            at NPD. NPD data are updated every night. During this time, NPDs services and portals are unavailable, and the user will not be able
                            fetch data.""")
                    st.write("""The application has several features. The features per December 2023 are FIELD DEVELOPMENT, 
                             RESERVOIR PRESSURE FROM PRODUCTION DATA, and NPD DATA. The user can switch back and forth among the features. The resulting plots 
                             will be stored/cached while the application is running.""")
                             
                    st.write("""The field development feature can be used for estimating production profiles for dry-gas fields.
                             The reservoir pressure from production data feature can be used for estimating the decline in pressure for a dry-gas reservoir when the produced gas rates are known. 
                             The NPD data feature can be used for NCS field investigation. The feature offers a service that lets you compare production volumes
                             from different fields and plot the reservoir area (polygon) with well locations.""")
                
                on_more_about = st.toggle("Show me more information about the specialization project", value=False, label_visibility="visible")
                if on_more_about:
                    st.write("""Integrated petroleum production systems are typically modeled and simulated using Excel spread-
                            sheets, or specialized software. As part of my specialization project the following application was made in an attempt to 
                            make a platform for computational routines for the Simulation and Modeling of Integrated Petroleum Production Systems.The
                            web-application has been built in Python, utilizing the Streamlit library. The application is free for everyone to use.
                            See the report for more information. 
                            """)
                st.write(" ")
                st.write(" ")
                st.write(" ")
                st.write(" ")
                st.write('Specialization project by Morten Simensen, supervised by associate professor Milan Stanko')

        elif opt == 'FIELD DEVELOPMENT':
            self.field_development = FIELD_DEVELOPMENT(parent=GUI)
        elif opt == 'RESERVOIR PRESSURE FROM PRODUCTION DATA':
             self.reservoir_pressure_from_production_data = RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA(self)
        elif opt == 'NPD DATA':
             self.NPD_DATA = NPD_DATA(GUI)           

class FIELD_DEVELOPMENT(GUI):
    def __init__(self, parent):
        from Modules.FIELD_DEVELOPMENT.run_Analysis import DryGasAnalysis
        Analysis = DryGasAnalysis(parent = FIELD_DEVELOPMENT, session_id='DryGasAnalysis')
        on_information = st.toggle("Show me information on how to use the field development feature", value=False, label_visibility="visible")
        if on_information:
            st.write("""The table below on the right side contains default values for 16 parameters, in which the production profile estimation
                     is based upon. The values can be changed as the user sees fit. For example, if the user wants to run with a pressure of 
                     250 bara, and a different temperature, click the values in the table and change them to the desired values directly.""")
            st.write(""" 
                    The production profile is estimated with the values in the table when the user clicks <Run Analysis>. 
                    The first production profile will display as Prod-profile 1. The parameters used for each Prod-profile are stored. The
                    user can change the parameters and click <Run Analysis> again. This will display a second prod-profile.
                    The user can create as many production profiles as desired.""")
                     
            st.write("""The <Compare different models> button
                     will create a new plot, where all the production profiles are compared in one plot.""")
            st.write( 
                    """Each production profile plot contains a dropdown menu. From the dropdown menu, sub-calculations for the production profile can be displayed 
                    instead of the production profile. This includes among other, Recovery Factor, Z-factor, Reservoir pressure and choke pressure.""")
            
            st.write("""
                    Clicking the <Clear output> button will remove all the plots and stored parameters. You will start over creating 
                    production profile 1 again after clicking this button.""")
                     
            st.write("""The feature has a <Choose field to compare with> dropdown menu. By choosing a field from NPD, 
                     instead of default "No Field Chosen", the daily average SM^3 volumes of water, oil, gas and condensate rates for that particular field are possible to 
                     display for the user.""")
            st.write("""
                     There is also two options the user can choose from to run different models. 
                     These options decide the mathematical method for obtaining the production profile. 
                     By default the production profile is estimated using implicit Nodal approach. However, from the two dropdown menu, the user can choose 
                    IPR instead of Nodal, and explicit instead of implicit. Nodal implicit is the most accurate method, but 
                     also the most computational costly. For more details see the report. 
                     """)

        col0, col1 = st.columns(2)
        plot_comp = False
        with col0:
            method, precision = display.columnDisplay2(list1=[['NODAL', 'IPR'], ['IMPLICIT', 'EXPLICIT']])
            col4, col5 = st.columns(2)
            with col4:
                run = st.button('Run Analysis', 'Run DG')
            with col5: 
                if st.button('Compare different models', 'Compare'):
                        plot_comp = True
            col7, col8 = st.columns(2)
            with col7:
                clear =  st.button('Clear output', 'clear FD')
            with col8: 
                field = display.dropdown(label = 'Choose a field to compare with', options = fieldnames, labelVisibility="visible")
                Analysis.updateField(field)
        with col1:  
            Analysis.updateFromDropdown(method = method, precision=precision)
            Analysis.updateParameterListfromTable() 
        
        if clear:
            Analysis.clear_output()

        field_name = Analysis.get_current_field()
        if run and field_name == 'No field chosen':
            result = Analysis.run()
            Analysis.append_result(result)

        elif run and field_name != 'No field chosen':
            result = Analysis.run_field(field)
            Analysis.append_result(result)
        col10, col11, col12, col13, col14 = st.columns(5)
        with col11:
            if plot_comp == True:
                Analysis.plot(comp = True)
            Analysis.plot()
            self.parent = parent

class RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA(GUI):
    def __init__(self, parent):
        self.place_holder = 1
        on_information = st.toggle("Show me information on how to use the reservoir pressure from production data feature", value=False, label_visibility="visible")
        if on_information:
            st.write(""" The user has some options for running the model. As per now only one equation is available, but the user can choose to fetch
                     monthly or yearly rates from NPD using the dropdownmenu below on the left side""")

            st.write(""" Choose production data from an NCS-field from the dropdown menu below, or upload data. Use the following format when uploading: 
                     column 0 - gas produced in sm3, column 1 - date (year/ year-month). use ; as seperator""")
            
            st.write("""Click <Run Analysis> to estimate the reservoir pressure for a field chosen, or for the uploaded data.
                      The numbers in the table below on the right side will be used for the estimation. The user can change these numbers before
                     clicking <Run Analysis>""")
            
            st.write("""An alternative to clicking <Run Analysis> is to click <Get NPD-data for field>. The IGIP and Reservoir pressure will be 
                     fetched from NPD and an analysis wil be run with this data. """)

                     
            st.write("""Click <Clear output> to remove all the plots and start over again""")

        uploaded = st.file_uploader(label = "Upload a CSV file")
        col0, col1 = st.columns(2)
        with col0:
            eq = display.dropdown(label = 'What equation do you want to use?', options = ['Material balance with Z-factor calculation'], labelVisibility="visible")
            if eq == 'Backpressure equation':
                pass     
            field = display.dropdown(label = 'Get gas production data from the following field:', options = fieldnames, labelVisibility="visible")
            selected_time = display.dropdown(label = 'Choose yearly or monthly producted volumes', options = ['Yearly', 'Monthly'], labelVisibility="visible")
        
        from Modules.RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA.run_R_analysis import ReservoirPressureAnalysis
        RES_Analysis = ReservoirPressureAnalysis(parent = RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA, session_id='ReservoirPressureAnalysis')
        RES_Analysis.updateFromDropDown(fieldName= field, time = selected_time)
        RES_Analysis.update_from_upload(uploaded)
        with col1:
            col2, col3, col4, col5= st.columns(4)
            with col2:   
                run = st.button('Run Analysis', 'Run RP')
            with col4:   
                NPD_button = st.button('Get NPD-data for field', 'get NPD data into table')
            with col5: 
                clear = st.button('Clear output', 'clear RESPRES')
        
        if NPD_button and field == 'No field chosen':
            alert3 = st.warning('Choose a field')
            time.sleep(1.5)
            alert3.empty()

        if run and field == 'No field chosen' and uploaded == None:
            alert3 = st.warning('Choose a field or upload data')
            time.sleep(1.5)
            alert3.empty()

        elif NPD_button and field != 'No field chosen':
            self.place_holder = 2
        
        with col1:
            if self.place_holder == 1:
                RES_Analysis.updateParameterListfromTable(list2 = manualData_RP())

            elif self.place_holder ==2:
                PRi = 276 #reservoir pressure bara #default value
                gasMolecularWeight = 16 #[g/mol] default value
                PRi, T, gasMolecularWeight, IGIP = RES_Analysis.get__PR_NPD_data()
                updated_list = [PRi, T, gasMolecularWeight, IGIP]
                RES_Analysis.updateParameterListfromTable(list2 = updated_list)
                alert4 = st.warning('Found estimates for IGIP and Temperature. Running Analysis with the data above')
                time.sleep(3)
                alert4.empty()
                if field != 'No field chosen' and selected_time == 'Yearly':
                    result = RES_Analysis.runY()
                    RES_Analysis.append_result(result)

                elif field != 'No field chosen' and selected_time == 'Monthly':
                    result = RES_Analysis.runM()
                    RES_Analysis.append_result(result)
 
        if run and field != 'No field chosen' and selected_time == 'Yearly':
            result = RES_Analysis.runY()
            RES_Analysis.append_result(result)

        elif run and field != 'No field chosen' and selected_time == 'Monthly':
            result = RES_Analysis.runM()
            RES_Analysis.append_result(result)

        elif run and uploaded != None:
            result = RES_Analysis.run_uploaded()
            RES_Analysis.append_result(result) 

        if clear:
            RES_Analysis.clear_output()
        col6, col7, col8, col9, col10 = st.columns(5)
        with col7:
            RES_Analysis.plot()
        self.parent = parent
        
class NPD_DATA(GUI):
    def __init__(self, parent):
        on_information = st.toggle("Show me information on how to use the NPD data feature", value=False, label_visibility="visible")
        if on_information:
            st.write(""" To compare fields follow these steps, 'Step 1 - Choose a field, Step 2- Click Plot production profile, Step 3 - 
                     Repeat step 1 and 2, Step 4 - Click Compare fields'""")
            
            st.write(""" Click clear output to remove all the plots and start over again'""")

            st.write("""" Click Plot reservoir area to plot a polygon of the reservor area with the production wells marked""")

        from Modules.NPD_DATA.npd_data import npd_prod
        npd_obj = npd_prod(parent = NPD_DATA, session_id='npd_prod', field = 'No field chosen')
        col4, col5  = st.columns(2)
        with col4:
            field = display.dropdown(label = 'Choose a field', options = fieldnames, labelVisibility="visible")
        with col5:
            time = display.dropdown(label = 'Time frame of interest', options = ['Yearly', 'Monthly'], labelVisibility="visible")
        
        npd_obj.updateFromDropDown(fieldName = field, time = time)
        col6, col7, col8 = st.columns(3)
        with col6:
            run = st.button('Plot production profile', 'Show produced volumes')
        with col7:
            comp = st.button('Compare fields', 'Compare')
        with col8: 
            clear =  st.button('Clear output', 'clear FD')
        
        if run and field == 'No field chosen':
            import time as t
            alert3 = st.warning('Choose a field first')
            t.sleep(1.5)
            alert3.empty()
        
        elif run and time == 'Yearly':
            result = npd_obj.runY()
            npd_obj.append_result(result)

        elif run and time == 'Monthly':
            result = npd_obj.runM()
            npd_obj.append_result(result)

        if clear:
            npd_obj.clear_output()

        if comp:
            npd_obj.plot(comp = True)
        npd_obj.plot()
        self.parent = parent

        st.write(' ')
        st.write(' ')
        st.write(' ')

        poly_button = st.button('Plot reservoir area', 'polygon plotter', use_container_width=True)
        if poly_button and field == 'No field chosen':
            import time
            alert4 = st.warning('Choose a field first')
            time.sleep(1.5)
            alert4.empty()
        elif poly_button and field != 'No field chosen':
            from Modules.NPD_DATA.npd_data import makePlot
            makePlot(field)
        show_more_prod = st.toggle(label = "Show me more information about the producing wells on this field")    
        if show_more_prod:
            st.dataframe(get.producing_wlb(field))
        show_more_inj = st.toggle(label = "Show me more information about the injection wells on this field") 
        if show_more_inj:
            st.dataframe(get.injecting_wlb(field))
        
        show_more_closed = st.toggle(label = "Show me more information about the closed wells on this field") 
        if show_more_closed:
            st.dataframe(get.closed_wlb(field))
        show_more_PA = st.toggle(label = "Show me more information about the P&A wells on this field") 
        if show_more_PA:
            st.dataframe(get.PA_wlb(field))





# File: .\GUI\GUI_functions.py
import pandas as pd, plotly.graph_objects as go, streamlit as st
def multi_plot_PR(dfs, addAll = True, addProduced = False):
    fig = go.Figure()
    columns_to_plot = []

    for df in dfs:
        if addProduced:
            columns_to_plot += ['Field rates [sm3/d]', 'gasSM3perday']
            all_label = 'Estimated vs Actual produced rates'
        else:
            columns_to_plot += df.columns.to_list()
            all_label = 'All'

        for column in columns_to_plot:
            fig.add_trace(
                go.Scatter(
                    x = df.index,
                    y = df[column],
                    name = column,
                    visible = 'legendonly' if not addAll and column != df.columns[0] else True  # Change visibility here
                )
            )

    button_all = dict(label = all_label,
                    method = 'update',
                    args = [{'visible': [True]*len(columns_to_plot),
                            'title': all_label,
                            'showlegend':True}])

    def create_layout_button(column):
        return dict(label = column,
                    method = 'update',
                    args = [{'visible': [column == col for col in columns_to_plot],
                            'title': column,
                            'showlegend': True}])

    all_buttons = ([button_all] * addAll) + [create_layout_button(column) for column in columns_to_plot]

    # Add buttons for all columns in the dataframe
    all_buttons += [create_layout_button(column) for column in df.columns if column not in columns_to_plot]

    fig.update_layout(
        updatemenus=[go.layout.Updatemenu(
            active = 0 if addAll else columns_to_plot.index(columns_to_plot[0]),  # Change active button here
            buttons = all_buttons
            )
        ],
        showlegend=addAll,  # Change showlegend here
        xaxis_title="Date",  # X-axis title
        yaxis_title="Pressure [bara]"  # Y-axis title
    )

    # Update remaining layout properties
    fig.update_layout(
        height=600,
        width=1000
    
    )
    st.plotly_chart(fig)

def multi_plot(dfs, addAll = True, addProduced = False):
    fig = go.Figure()
    columns_to_plot = []

    for df in dfs:
        if addProduced:
            columns_to_plot += ['Field rates [sm3/d]', 'gasSM3perday']
            all_label = 'Estimated vs Actual produced rates'
        else:
            columns_to_plot += df.columns.to_list()
            all_label = 'All'

        for column in columns_to_plot:
            fig.add_trace(
                go.Scatter(
                    x = df.index,
                    y = df[column],
                    name = column,
                    visible = 'legendonly' if not addAll and column != df.columns[0] else True  # Change visibility here
                )
            )

    button_all = dict(label = all_label,
                    method = 'update',
                    args = [{'visible': [True]*len(columns_to_plot),
                            'title': all_label,
                            'showlegend':True}])

    def create_layout_button(column):
        return dict(label = column,
                    method = 'update',
                    args = [{'visible': [column == col for col in columns_to_plot],
                            'title': column,
                            'showlegend': True}])

    all_buttons = ([button_all] * addAll) + [create_layout_button(column) for column in columns_to_plot]

    # Add buttons for all columns in the dataframe
    all_buttons += [create_layout_button(column) for column in df.columns if column not in columns_to_plot]

    fig.update_layout(
        updatemenus=[go.layout.Updatemenu(
            active = 0 if addAll else columns_to_plot.index(columns_to_plot[0]),  # Change active button here
            buttons = all_buttons
            )
        ],
        showlegend=addAll,  # Change showlegend here
        xaxis_title="Year",  # X-axis title
        yaxis_title="Cubic meter"  # Y-axis title
    )

    # Update remaining layout properties
    fig.update_layout(
        height=600,
        width=1000
    
    )
    st.plotly_chart(fig)

def display_table(list1, list2, edible=False):
    df_table = pd.DataFrame({
        'Input': list1,
        'Value': list2
    })
    if edible:
        edited_df = st.data_editor(df_table, key='df_table_editor', width=750, height=596, hide_index=True)
        return edited_df['Value'].to_list()
    else:
        st.table(df_table)

def display_table_RESPRES(list1, list2, edible = False, clear_table = False) ->list:
    # Create a DataFrame from the two lists
    df_table = pd.DataFrame({
        'Input': list1,
        'Value': list2
    })

    if edible:
        edited_df = st.data_editor(df_table, key='df_table_editor', width=790, height=175, hide_index=True)
        return edited_df['Value'].to_list()

class edible_df():
    def __init__(self, list2):
        self.df = self.initialize_table(list2)
    def initialize_table(self, list2):
        list1 = ['Initial Reservoir Pressure [bara]', 'Reservoir Temperature [degree C]', 'Gas Molecular Weight [g/mol]', 'Initial Gas in Place [sm3]']
        self.df_table = pd.DataFrame({
            'Input': list1,
            'Value': list2
        })
        edited_df = st.data_editor(self.df_table, key='df_table_editor', width=790, height=175, hide_index=True)
        return edited_df
    def update_table(self, new_values):
        self.df_table['Value'] = new_values
        return st.data_editor(self.df_table, key='df_table_editor__', width=790, height=175, hide_index=True)
    
    def get_parameters(self):
        return self.df_table['Value'].to_list()
        
def dropdown(label:str = ' ', options: list = None, index:int = 0, labelVisibility: str ='collapsed') ->str:
    selected_option = st.selectbox(label, options, index, label_visibility=labelVisibility)
    return selected_option

def columnDisplay(list1:list):
    col1, col2, col3 = st.columns(3)

    with col1:
        selected_option1 = dropdown(options = list1[0])

    with col2:
        selected_option2 = dropdown(options = list1[1])

    with col3:
        selected_option3 = dropdown(options = list1[2])
    return selected_option1, selected_option2, selected_option3

def columnDisplay2(list1:list):
    col1, col2 = st.columns(2)

    with col1:
        selected_option1 = dropdown(options = list1[0])

    with col2:
        selected_option2 = dropdown(options = list1[1])

    return selected_option1, selected_option2

def columnDisplay1(list1:list):
    col1 = st.columns(2)

    with col1:
        selected_option1 = dropdown(options = list1)

    return selected_option1


# File: .\GUI\__init__.py



# File: .\Modules\__init__.py



# File: .\Modules\FIELD_DEVELOPMENT\run_Analysis.py
import pandas as pd
from Data.Storage.Cache import SessionState
import GUI.GUI_functions as display
from Data.ManualData import manualData
from GUI.GUI_class import FIELD_DEVELOPMENT

class DryGasAnalysis(FIELD_DEVELOPMENT):
    def __init__(self, parent, session_id:str, inputs:list = [], method:str = None, precision:str = None, field:str = 'No field chosen'):
        self.__parameters:list = inputs
        self.__method = method
        self.__precision = precision
        self.__field = field
        self.__session_id = session_id
        self.__result = pd.DataFrame()
        self.__state = SessionState.get(id=session_id, result=[], method=[], precision=[], field=[])
        self.parent  = parent

    def updateFromDropdown(self, method, precision):
            self.__method, self.__precision = method, precision

    def updateField(self, fieldName):
         self.__field = fieldName
    
    def get_current_field(self):
        return self.__field
    def get_current_method(self):
        return self.__method
    def get_current_precision(self):
        return self.__precision
    def get_current_result(self):
        return self.__result


    def updateParameterListfromTable(self):
        list1 = ['Target Rate [sm3/d]', 'Initial Reservoir Pressure [bara]', 'Rate of Abandonment [sm3/d]', 'Reservoir Temperature [degree C]', 'Gas Molecular Weight [g/mol]', 'Inflow backpressure coefficient', 'Inflow backpressure exponent', 'Number of Templates', 'Number of Wells per Template', 'Uptime [days]', 'Tubing Flow Coefficient', 'Tubing Elevation Coefficient', 'Flowline Coefficient from Template-PLEM', 'Pipeline coefficient from PLEM-Shore', 'Seperator Pressure [bara]', 'Initial Gas in Place [sm3]']
        self.__parameters.append(display.display_table(list1=list1, list2=manualData(), edible=True))

    def run(self):
        self.append_method(self.__method)
        self.append_precision(self.__precision)
        self.append_field(self.__field)
        if self.__method == 'IPR':
            from Modules.FIELD_DEVELOPMENT.IPR.IPRAnalysis import IPRAnalysis
            df = IPRAnalysis(self.__precision, self.__parameters[-1])
        else:
            from Modules.FIELD_DEVELOPMENT.Nodal.NodalAnalysis import NodalAnalysis
            df = NodalAnalysis(self.__precision, self.__parameters[-1])
        self.__result = df
        return df
    
    def run_field(self, field):
        self.append_method(self.__method)
        self.append_precision(self.__precision)
        self.append_field(field)

        if self.__method == 'IPR':
            from Modules.FIELD_DEVELOPMENT.IPR.IPRAnalysis import IPRAnalysis
            df = IPRAnalysis(self.__precision, self.__parameters[-1])
        else:
            from Modules.FIELD_DEVELOPMENT.Nodal.NodalAnalysis import NodalAnalysis
            df = NodalAnalysis(self.__precision, self.__parameters[-1])
        import Data.dataProcessing as dP
        df = dP.addActualProdYtoDF(field, df)
        df = dP.addProducedYears(field, df)
        return df
    
    def plot(self, comp=False):
        import streamlit as st
        from pandas import DataFrame
        res = self.getResult()
        if comp == False:
            for i in range(len(res)):
                if isinstance(res[i], DataFrame):
                    field = self.getField()
                    method = self.getMethod()
                    prec = self.getPrecision()
                    st.header('Prod-profile: ' + str(i + 1), divider='red')
                    if field[i] != 'No field chosen':
                        st.write(method[i], prec[i], field[i])
                        display.multi_plot([res[i]], addProduced=True)
                    else:
                        st.write(method[i], prec[i])
                        display.multi_plot([res[i]], addAll=False)
        else:
            dfs = []
            for df in self.__state.result:
                reset_ind_df = df.reset_index(drop = True)
                dfs.append(reset_ind_df)
            st.header('Compared models', divider='red')
            display.multi_plot(dfs, addAll=False)
    

    def clear_output(self):
        from Data.Storage.Cache import SessionState
        SessionState.delete(id = 'DryGasAnalysis')
        self.__state = SessionState.get(self.__session_id, result=[], method=[], precision=[], field=[])
    

    def getMethod(self) -> str:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'method', None)

    def getPrecision(self) -> str:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'precision', None)

    def getResult(self) -> list:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'result', [])

    def getParameters(self) -> pd.DataFrame:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'parameters', pd.DataFrame())
    
    def getField(self) -> pd.DataFrame:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'field', pd.DataFrame())

    def getState(self) -> SessionState:
        session_state = self.__state.get(self.__session_id)
        return session_state
    
    def append_method(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'method', value = item)

    def append_precision(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'precision', value = item)

    def append_result(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'result', value = item)

    def append_parameters(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'parameter', value = item)
    
    def append_field(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'field', value = item)
        



# File: .\Modules\FIELD_DEVELOPMENT\__init__.py



# File: .\Modules\FIELD_DEVELOPMENT\IPR\dfIPRExplicit.py
import pandas as pd
import numpy as np
from Equations.ZfacStanding import ZfacStanding
from Equations.pWfMinEstimation import pWfMinEstimation
from IPR.qPotWell import qPotWell
import Equations.DryGasFlowEquations as DGFE
from Equations.MBgastank_PR import MBgastank_PR
from Equations.RF import RF
from scipy.optimize import fsolve

def IPROnly(qFieldTarget: float, PRi: float, abandonmentRate: float, TR:float, gasMolecularWeight: float, C_R: float, n:float, N_temp: float, NWellsPerTemplate: float, upTime: int, C_t: float, S:float, C_FL:float, C_PL:float, P_sep: float, IGIP: float) -> pd.DataFrame:
    """
    qFieldTarget =  plateau rate, [sm3/day]
    PRi = initial reservoir pressure, [bara]
    abandonmentRate = rate for abandonment, [sm3/day]
    gasMolecularWeight = molecular weight of gas at standard conditions #[g/mol],
    C_R = inflow backpressure coefficient,
    n = Inflow backpressure exponent,
    N_temp = number of templates
    NWellsPerTemplate = number of wells per template. Assumes the same amount of wells per template.
    upTime = number of operational days in a year, 
    C_t = tubing flow coefficient, 
    S = tubing elevation coefficient,
    C_FL = flowline coefficient from template-PLEM ,
    C_PL = Pipeline coefficient from PLEM-Shore,
    p_sep = seperator pressure [bara],
    IGIP = initial gas in place [sm3].
    """
    ticker = 0
    years = 200 #maximum simulation time 200 years
    NWells = N_temp*NWellsPerTemplate
    df = pd.DataFrame(np.zeros((years, 13)))
    df[0][0:years] = qFieldTarget #QFieldTarget, what we want our field to produce   
    df[1][0:years] = df[0]/NWells #qWell Target, what we want each well to produce
    fieldRate = qFieldTarget #assuming we can produce the target rate initially 
    #estimating the minimim bottomhole pressure
    pWfMin = pWfMinEstimation(C_t, S, C_FL, C_PL, fieldRate, P_sep, N_temp, NWellsPerTemplate) 
    df[4][0:years] = pWfMin #assuming PwfMin is constant during the fields lifetime
    #calculating initial Zfactor.
    Zi = ZfacStanding(PRi, TR, gasMolecularWeight)
    i = 0
    while (i<years): #Doing the calculations for each year
        if i == 0: 
            df[2][0] = PRi #Initial reservoir pressure year 0
            df[9][0] = 0 #initial yearly gas of take = 0
            df[10][0] = 0 #initial cumulative gas of take = 0    
        else:
            #calculating the reservoir pressure with time numerically using scipy fsolve
            def f(x, df):
                df[5][i] = qPotWell(C_R, n, x, pWfMin) #potential flow for one well
                df[6][i] = df.iloc[i, 5] * NWells #potential for field  
                if df.iloc[i, 6] >= qFieldTarget: #checking if we have high enough potential to produce desired plateau rate
                    df[7][i] = qFieldTarget
                else: #if we cant produce our target rate, the plateau period is ended.
                    df[7][i]= df.iloc[i, 6]          
                df[9][i] = df.iloc[i-1, 7]*upTime #yearly gas offtake = rates [sm3/day] * upTime[days]

                df[10][i] = df.iloc[i-1, 10] + df.iloc[i, 9]          
                return x - MBgastank_PR(PRi, Zi, ZfacStanding(df.iloc[i-1, 2], TR, gasMolecularWeight), RF(df[10][i], IGIP ))         
            a = fsolve(f, pWfMin, df)
            df[2][i] = a    
        #calculating the z-factor which is dependent on the reservoir pressure which in its turn is dependent on the z-factor
        df[3][i] = ZfacStanding(df.iloc[i, 2], TR, gasMolecularWeight)
        df[5][i] = qPotWell(C_R, n, df.iloc[i, 2], pWfMin) #potential flow for one well
        df[6][i] = df.iloc[i, 5] * NWells #potential for field  
        if df.iloc[i, 6] >= qFieldTarget: #checking if we have high enough potential to produce desired plateau rate
            df[7][i] = qFieldTarget
        else: #if we cant produce our target rate, the plateau period is ended.
            df[7][i] = df.iloc[i, 6] #lower potential than wanted then then we produce what we can     
            #if we produce less than abandonmentRate we have reached abandoment
            if (df.iloc[i, 7]) < abandonmentRate and ticker == 0: 
                abandonmentLength = i
                years = i 
                df = df.iloc[0:years+1, :] #we are not interested in doing more calculations.
                ticker = 1
                break
        df[8][i] = df.iloc[i, 7] / NWells #what we produce per well 
        df[11][i] = RF(df[10][i], IGIP) # recovery factor. 
        PWf = DGFE.IPRpwf(C_R, n, df.iloc[i, 2], df.iloc[i, 8])
        df[12][i] = PWf # potential wellflow
        i+=1
    return df





# File: .\Modules\FIELD_DEVELOPMENT\IPR\dfIPRImplicit.py
import pandas as pd
import numpy as np
from Equations.ZfacStanding import ZfacStanding
from Equations.pWfMinEstimation import pWfMinEstimation
from Modules.FIELD_DEVELOPMENT.IPR.qPotWell import qPotWell
import Equations.DryGasFlowEquations as DGFE
from Equations.MBgastank_PR import MBgastank_PR
from Equations.RF import RF
from scipy.optimize import fsolve

def IPROnly(qFieldTarget: float, PRi: float, abandonmentRate: float, TR:float, gasMolecularWeight: float, C_R: float, n:float, N_temp: float, NWellsPerTemplate: float, upTime: int, C_t: float, S:float, C_FL:float, C_PL:float, P_sep: float, IGIP: float) -> pd.DataFrame: 
    """
    qFieldTarget =  plateau rate, [sm3/day]
    PRi = initial reservoir pressure, [bara]
    abandonmentRate = rate for abandonment, [sm3/day]
    gasMolecularWeight = molecular weight of gas at standard conditions #[g/mol],
    C_R = inflow backpressure coefficient,
    n = Inflow backpressure exponent,
    N_temp = number of templates
    NWellsPerTemplate = number of wells per template. Assumes the same amount of wells per template.
    upTime = number of operational days in a year, 
    C_t = tubing flow coefficient, 
    S = tubing elevation coefficient,
    C_FL = flowline coefficient from template-PLEM ,
    C_PL = Pipeline coefficient from PLEM-Shore,
    p_sep = seperator pressure [bara],
    IGIP = initial gas in place [sm3].
    """
    ticker = 0
    years = 200 #maximum simulation time 200 years
    NWells = N_temp*NWellsPerTemplate
    df = pd.DataFrame(np.zeros((years, 13)))
    df[0][0:years] = qFieldTarget #QFieldTarget, what we want our field to produce
    df[1][0:years] = df[0]/NWells #qWell Target, what we want each well to produce
    fieldRate = qFieldTarget #assuming we can produce the target rate initially
    #estimating the minimim bottomhole pressure
    pWfMin = pWfMinEstimation(C_t, S, C_FL, C_PL, fieldRate, P_sep, N_temp, NWellsPerTemplate) 
    df[4][0:years] = pWfMin #assuming PwfMin is constant during the fields lifetime
    #calculating initial Zfactor.
    Zi = ZfacStanding(PRi, TR, gasMolecularWeight)
    i = 0
    while (i<years): #Doing the calculations for each year
        if i == 0: 
            df[2][0] = PRi #Initial reservoir pressure year 0
            df[9][0] = 0
            df[10][0] = 0   
        else:
            #calculating the reservoir pressure with time numerically using scipy fsolve
            def f(x, df):
                df[5][i] = qPotWell(C_R, n, x, pWfMin) #potential flow for one well
                df[6][i] = df.iloc[i, 5] * NWells #potential for field 
                if df.iloc[i, 6] >= qFieldTarget: #checking if we have high enough potential to produce desired plateau rate
                    df[7][i] = qFieldTarget
                else: #if we cant produce our target rate, the plateau period is ended.
                    df[7][i]= df.iloc[i, 6] #lower potential than wanted then then we produce what we can
            #if we produce less than abandonmentRate we have reached abandoment
                df[9][i] = df.iloc[i-1, 7]*upTime #yearly gas offtake = rates [sm3/day] * upTime[days]
                df[10][i] = df.iloc[i-1, 10] + df.iloc[i, 9]
                return x - MBgastank_PR(PRi, Zi, ZfacStanding(x, TR, gasMolecularWeight), RF(df[10][i], IGIP ))
            a = fsolve(f, pWfMin, df)
            df[2][i] = a
        #calculating the z-factor which is dependent on the reservoir pressure which in its turn is dependent on the z-factor
        df[3][i] = ZfacStanding(df.iloc[i, 2], TR, gasMolecularWeight)
        df[5][i] = qPotWell(C_R, n, df.iloc[i, 2], pWfMin) #potential flow for one well
        df[6][i] = df.iloc[i, 5] * NWells #potential for field 
        if df.iloc[i, 6] >= qFieldTarget: #checking if we have high enough potential to produce desired plateau rate
            df[7][i] = qFieldTarget
        else: #if we cant produce our target rate, the plateau period is ended.
            df[7][i] = df.iloc[i, 6] #lower potential than wanted then then we produce what we can            
            #if we produce less than abandonmentRate we have reached abandoment
            if (df.iloc[i, 7]) < abandonmentRate and ticker == 0: 
                abandonmentLength = i
                years = i 
                df = df.iloc[0:years+1, :] #we are not interested in doing more calculations.
                ticker = 1
                break    
        df[8][i] = df.iloc[i, 7] / NWells #what we produce per well 
        df[11][i] = RF(df[10][i], IGIP)
        PWf = DGFE.IPRpwf(C_R, n, df.iloc[i, 2], df.iloc[i, 8])
        df[12][i] = PWf
        i+=1
    return df




# File: .\Modules\FIELD_DEVELOPMENT\IPR\IPRAnalysis.py
from Data.ManualData import manualData
import Data.dataProcessing as dP 

def IPRAnalysis(precision: str, parameters: list = manualData()):
    if precision == 'Explicit':
        from Modules.FIELD_DEVELOPMENT.IPR.dfIPRExplicit import IPROnly
    else: 
        from Modules.FIELD_DEVELOPMENT.IPR.dfIPRImplicit import IPROnly
    df = IPROnly(*parameters)
    df.columns=('QFieldTarget [sm3/d]', 'qWellTarget[sm3/d]', 'Reservoir pressure [bara]', 'Z-factor', ' Minimum bottomhole pressure [bara]', 'Potential rates per well [sm3/d]', 'Potential field rates [sm3/d]', 'Field rates [sm3/d]', 'Well production rates [sm3/d]', 'yearly gas offtake [sm3]', 'Cumulative gas offtake [sm3]', 'Recovery Factor', 'Bottomhole pressure [bara]')
    df = swapColumns(df, 'QFieldTarget [sm3/d]', 'Field rates [sm3/d]')
    return df

def swapColumns(df, col1, col2):
    col_list = list(df.columns)
    x, y = col_list.index(col1), col_list.index(col2)
    col_list[y], col_list[x] = col_list[x], col_list[y]
    df = df[col_list]
    return df





      




      





# File: .\Modules\FIELD_DEVELOPMENT\IPR\qPotWell.py
from Equations.DryGasFlowEquations import IPRqg
def qPotWell(C_R, n, P_R_PreviousYear, PWfMin):
    """
    Returns potential wellflow given:
    P_R_PreviousYear = Reservoir pressure previous year
    C_R = inflow backpressure coefficient
    n = inflow backpressure coefficient
    PWfMin = minimum bottomhole pressure
    
    """
    
    q_potWell = IPRqg(C_R, n, P_R_PreviousYear, PWfMin)
    return q_potWell





# File: .\Modules\FIELD_DEVELOPMENT\IPR\__init__.py



# File: .\Modules\FIELD_DEVELOPMENT\Nodal\dfNodalExplicit.py
import pandas as pd
import numpy as np
from Equations.ZfacStanding import ZfacStanding
import Equations.DryGasFlowEquations as DGFE
from Equations.MBgastank_PR import MBgastank_PR
from Equations.RF import RF
from scipy.optimize import fsolve
def Nodal(qFieldTarget: float, PRi: float, abandonmentRate: float, TR:float, gasMolecularWeight: float, C_R: float, n:float, N_temp: float, NWellsPerTemplate: float, upTime: int, C_t: float, S:float, C_FL:float, C_PL:float, P_sep: float, IGIP: float) -> pd.DataFrame: 
    """
    qFieldTarget =  plateau rate, [sm3/day]
    PRi = initial reservoir pressure, [bara]
    abandonmentRate = rate for abandonment, [sm3/day]
    gasMolecularWeight = molecular weight of gas at standard conditions #[g/mol],
    C_R = inflow backpressure coefficient,
    n = Inflow backpressure exponent,
    N_temp = number of templates
    NWellsPerTemplate = number of wells per template. Assumes the same amount of wells per template.
    upTime = number of operational days in a year, 
    C_t = tubing flow coefficient, 
    S = tubing elevation coefficient,
    C_FL = flowline coefficient from template-PLEM ,
    C_PL = Pipeline coefficient from PLEM-Shore,
    p_sep = seperator pressure [bara],
    IGIP = initial gas in place [sm3].
    """
    ticker = 0
    years = 200 #maximum simulation time 200 years
    NWells = N_temp*NWellsPerTemplate
    df = pd.DataFrame(np.zeros((years, 16)))
    Zi = ZfacStanding(PRi, TR, gasMolecularWeight)
    qField = qFieldTarget
    df[0][0:years] = qField #Assuming we can produce at the desired rate
    df[11][0:years] = P_sep #assuming constant seperator pressure
    i = 0
    while (i<years): #Doing the calculations for each year
        if i == 0: 
            df[1][0] = 0 #initial yearly gas of take = 0
            df[2][0] = 0 #initial cumulative gas of take = 0
            df[3][0] = 0 #recovery factor = 0
            df[4][i] = Zi
            df[5][0] = PRi #Initial reservoir pressure year 0       
        else:
            df[1][i] = df.iloc[i-1, 0]*upTime #yearly gas offtake = rates [sm3/day] * upTime[days]
            df[2][i] = df.iloc[i-1, 2] + df.iloc[i, 1]
            df[3][i] = RF(df.iloc[i, 2], IGIP)
            df[5][i] = MBgastank_PR(PRi, Zi, ZfacStanding(df.iloc[i-1, 5], TR, gasMolecularWeight), df.iloc[i, 3]) #P_res
            df[4][i] = ZfacStanding(df.iloc[i, 5], TR, gasMolecularWeight) # z-factor 
        x = df.iloc[i, 0]
        def f(x): #calculate potential produciton rate for choke 0, we then can determine how much we have to choke to reach desired rates
            return DGFE.Tubingp2(C_t, S, DGFE.IPRpwf(C_R, n, df.iloc[i, 5], x / NWells), x / NWells) - DGFE.Linep1(C_FL, DGFE.Linep1(C_PL, P_sep, x), x / N_temp)
        a = fsolve(f, df.iloc[i-1, 0])
        df[15][i] = a
        if df.iloc[i, 15] < qFieldTarget: #check if our potential is less than our desired rates
            df[0][i] = df.iloc[i, 15] #if so, then we must produce what we can
            df[13][i] = 0 #set choke to 0               
        df[6][i] = df.iloc[i, 0] / NWells #Qwell
        df[7][i] = DGFE.IPRpwf(C_R, n, df.iloc[i, 5], df.iloc[i, 6]) #Pwf
        df[8][i] = DGFE.Tubingp2(C_t, S, df.iloc[i, 7], df.iloc[i, 6]) #Pwh
        df[10][i] = DGFE.Linep1(C_PL, df.iloc[i, 11], df.iloc[i, 0]) #Pplem (pipeline entry module)
        df[12][i] = df.iloc[i, 0] / N_temp #Qtemp
        df[9][i] = DGFE.Linep1(C_FL, df.iloc[i, 10], df.iloc[i, 12]) #Ptemplate
        df[13][i] = round(df.iloc[i, 8] - df.iloc[i, 9])#deltaPChoke , simple model, difference between p_wh and p_template
        df[14][i] = df.iloc[i, 9] / df.iloc[i, 8]#ratio p_temp to p_wh
        if ((df.iloc[i, 0]) <= abandonmentRate and ticker == 0): 
            df = df.iloc[0:i+1, :] #we are not interested in doing more calculations than necessary
            ticker = 1
            years = i
            break
        i+=1
    return df







# File: .\Modules\FIELD_DEVELOPMENT\Nodal\dfNodalImplicit.py
import pandas as pd
import numpy as np
from Equations.ZfacStanding import ZfacStanding
import Equations.DryGasFlowEquations as DGFE
from Equations.pWfMinEstimation import pWfMinEstimation
from Equations.MBgastank_PR import MBgastank_PR
from Equations.RF import RF
from scipy.optimize import root
def Nodal(qFieldTarget: float, PRi: float, abandonmentRate: float, TR:float, gasMolecularWeight: float, C_R: float, n:float, N_temp: float, NWellsPerTemplate: float, upTime: int, C_t: float, S:float, C_FL:float, C_PL:float, P_sep: float, IGIP: float) -> pd.DataFrame: 
    """
    qFieldTarget =  plateau rate, [sm3/day]
    PRi = initial reservoir pressure, [bara]
    abandonmentRate = rate for abandonment, [sm3/day]
    gasMolecularWeight = molecular weight of gas at standard conditions #[g/mol],
    C_R = inflow backpressure coefficient,
    n = Inflow backpressure exponent,
    N_temp = number of templates
    NWellsPerTemplate = number of wells per template. Assumes the same amount of wells per template.
    upTime = number of operational days in a year, 
    C_t = tubing flow coefficient, 
    S = tubing elevation coefficient,
    C_FL = flowline coefficient from template-PLEM ,
    C_PL = Pipeline coefficient from PLEM-Shore,
    p_sep = seperator pressure [bara],
    IGIP = initial gas in place [sm3].
    """
    ticker = 0
    years = 200 #maximum simulation time 200 years
    NWells = N_temp*NWellsPerTemplate
    df = pd.DataFrame(np.zeros((years, 16)))
    Zi = ZfacStanding(PRi, TR, gasMolecularWeight)
    qField = qFieldTarget
    fieldRate = qFieldTarget
    df[0][0:years] = qField #Assuming we can produce at the desired rate
    df[11][0:years] = P_sep #assuming constant seperator pressure
    pWfMin = pWfMinEstimation(C_t, S, C_FL, C_PL, fieldRate, P_sep, N_temp, NWellsPerTemplate)
    i = 0
    while (i<years): #Doing the calculations for each year
        if i == 0: 
            df[1][0] = 0 #initial yearly gas of take = 0
            df[2][0] = 0 #initial cumulative gas of take = 0
            df[3][0] = 0 #recovery factor = 0
            df[4][i] = Zi
            df[5][0] = PRi #Initial reservoir pressure year 0        
        else:      
            def g(x, df):
                df[1][i] = df.iloc[i-1, 0]*upTime #yearly gas offtake = rates [sm3/day] * upTime[days]
                df[2][i] = df.iloc[i-1, 2] + df.iloc[i, 1]
                df[3][i] = RF(df.iloc[i, 2], IGIP)   
                return MBgastank_PR(PRi, Zi, ZfacStanding(x, TR, gasMolecularWeight), df.iloc[i, 3])-x
            b = root(g, pWfMin, df)
            df[5][i] = b.x
            df[4][i] = ZfacStanding(df.iloc[i, 5], TR, gasMolecularWeight) # z-factor  
        x = df.iloc[i, 0]
        def f(x): #calculate potential produciton rate for choke 0, we then can determine how much we have to choke to reach desired rates
            return DGFE.Tubingp2(C_t, S, DGFE.IPRpwf(C_R, n, df.iloc[i, 5], x / NWells), x / NWells) - DGFE.Linep1(C_FL, DGFE.Linep1(C_PL, P_sep, x), x / N_temp)
        a = root(f, df.iloc[i-1, 0])
        df[15][i] = a.x 
        if df.iloc[i, 15] < qFieldTarget: #check if our potential is less than our desired rates
            df[0][i] = df.iloc[i, 15] #if so, then we must produce what we can
            df[13][i] = 0 #set choke to 0          
        df[6][i] = df.iloc[i, 0] / NWells #Qwell
        df[7][i] = DGFE.IPRpwf(C_R, n, df.iloc[i, 5], df.iloc[i, 6]) #Pwf
        df[8][i] = DGFE.Tubingp2(C_t, S, df.iloc[i, 7], df.iloc[i, 6]) #Pwh
        df[10][i] = DGFE.Linep1(C_PL, df.iloc[i, 11], df.iloc[i, 0]) #Pplem (pipeline entry module)
        df[12][i] = df.iloc[i, 0] / N_temp #Qtemp
        df[9][i] = DGFE.Linep1(C_FL, df.iloc[i, 10], df.iloc[i, 12]) #Ptemplate
        df[13][i] = round(df.iloc[i, 8] - df.iloc[i, 9])#deltaPChoke , simple model, difference between p_wh and p_template
        df[14][i] = df.iloc[i, 9] / df.iloc[i, 8]#ratio p_temp to p_wh
        if (df.iloc[i, 0]) <= abandonmentRate and ticker == 0: 
            years = i 
            df = df.iloc[0:i+1, :] #we are not interested in doing more calculations than necessary
            return df
        i+=1
    return df



# File: .\Modules\FIELD_DEVELOPMENT\Nodal\NodalAnalysis.py
from Data.ManualData import manualData
import Data.dataProcessing as dP
def NodalAnalysis(precision: str, Parameters: list = manualData(), i = '1'):
    """precision = 'implicit' or 'explicit' and field. The implicit method is more accurate, but may fail due to root-finding problems."""
    if precision == 'Explicit':
        from Modules.FIELD_DEVELOPMENT.Nodal.dfNodalExplicit import Nodal
    else:
        from Modules.FIELD_DEVELOPMENT.Nodal.dfNodalImplicit import Nodal
    df = Nodal(*Parameters)
    df.columns=('Field rates [sm3/d]', 'yearly gas of take [sm3]', 'cumulative gas of take [sm3]', 'Recovery Factor', 'Z-factor', 'Reservoir pressure [bara]', 'Rates per well [sm3/d]', 'Bottomhole pressure [bara]', 'Wellhead pressure [bara]', 'Template pressure [bara]', 'Pressure pipeline entry module [bara]', 'Seperator pressure [Bara]', 'Rates per template [sm3/d]', 'choke pressure [bara]', 'ratio PTemp to PWellHead', 'Production Potential rates [Sm3/d]' )
    return df
    




# File: .\Modules\FIELD_DEVELOPMENT\Nodal\__init__.py



# File: .\Modules\NPD_DATA\npd_data.py
import pandas as pd
from Data.Storage.Cache import SessionState
import GUI.GUI_functions as display
from GUI.GUI_class import NPD_DATA
import streamlit as st
from shapely.wkt import loads
import plotly.graph_objects as go

class npd_prod(NPD_DATA):
    def __init__(self, parent, session_id:str, field:str = 'No field chosen'):
        self.__field = field
        self.__session_id = session_id
        self.__result = []
        self.__time_frame = []
        self.__state = SessionState.get(id=session_id, result=[], field=[], time_frame = [])
        self.parent  = parent

    def updateFromDropDown(self, fieldName, time):
         self.__field, self.__time_frame = fieldName, time
    
    def get_current_time_frame(self):
        return self.__time_frame
    def get_current_field(self):
        return self.__field
    def get_current_result(self):
        return self.__result

    def runY(self):
        self.append_field(self.__field)
        self.append_time_frame(self.__time_frame)  
        import Data.dataProcessing as dP
        df = dP.yearly_produced_DF(self.__field, df = pd.DataFrame())
        df = dP.addProducedYears(self.__field, df)
        return df
    
    def runM(self):
        self.append_field(self.__field)
        self.append_time_frame(self.__time_frame)  
        import Data.dataProcessing as dP
        df = dP.monthly_produced_DF(self.__field, df = pd.DataFrame())
        df = dP.addProducedMonths(self.__field, df)
        return df

    
    def plot(self, comp=False):
        import streamlit as st
        from pandas import DataFrame
        res = self.getResult()
        if comp == False:
            for i in range(len(res)):
                if isinstance(res[i], DataFrame):
                    field = self.getField()
                    st.title('Produced volumes: ' + field[i])
                    display.multi_plot([res[i]], addAll= False)
        else:
            dfs = []
            for df in self.__state.result:
                reset_ind_df = df.reset_index(drop = True)
                dfs.append(reset_ind_df)
            display.multi_plot(dfs, addAll=False)

    def clear_output(self):
        from Data.Storage.Cache import SessionState
        SessionState.delete(id = self.__session_id)
        self.__state = SessionState.get(id=self.__session_id, result=[], field=[], time_frame = [])
    

    def getResult(self) -> list:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'result', [])

    def get_time_frame(self) -> pd.DataFrame:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'time_frame', pd.DataFrame())
    
    def getField(self) -> pd.DataFrame:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'field', pd.DataFrame())

    def getState(self) -> SessionState:
        session_state = self.__state.get(self.__session_id)
        return session_state
    
    def append_time_frame(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'time_frame', value = item)

    def append_result(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'result', value = item)
    
    def append_field(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'field', value = item)
        
class PolygonPlotter:
    def __init__(self, wkt_str):
        self.wkt_str = wkt_str
        self.fig = self.plot()

    def plot(self):
        multipolygon = loads(self.wkt_str)
        traces = [
            go.Scatter(
                x=list(polygon.exterior.xy[0]),
                y=list(polygon.exterior.xy[1]),
                mode = 'lines',
                fill='toself',
                fillcolor='red',
                line=dict(color='white', width=1),
                name='Reservoir'
            ) for polygon in multipolygon.geoms
        ]

        fig = go.Figure(traces)
        fig.update_layout(
            height=800,
            width=800,
            xaxis_title="Longitude",
            yaxis_title="Latitude",
            showlegend=True,
            paper_bgcolor='black',
            plot_bgcolor='black'
        )

        return fig

def wlb_plot_production(fig, df, field):
    # Extract latitude and longitude from the WKT coordinates
    df[['Longitude', 'Latitude']] = df['wlbPointGeometryWKT'].str.extract(r'POINT \((\d+\.\d+) (\d+\.\d+)\)').astype(float)

    # Create a scatter trace
    scatter_trace = go.Scatter(
        x=df['Longitude'],
        y=df['Latitude'],
        text=df['wlbWellboreName'],  # Use the 'wlbWellboreName' column for text labels
        mode='markers', #+text
        name = "Production wells",
        marker=dict(size=10, color='white', symbol='circle'))

    # Add the scatter trace to the provided figure
    fig.add_trace(scatter_trace)

    # Update layout properties (optional)
    fig.update_layout(
        title='Reservoir and well locations ' + str(field),
        xaxis_title='Longitude',
        yaxis_title='Latitude',
    )

    return fig

def wlb_plot_injection(fig, df, field):
    # Extract latitude and longitude from the WKT coordinates
    df[['Longitude', 'Latitude']] = df['wlbPointGeometryWKT'].str.extract(r'POINT \((\d+\.\d+) (\d+\.\d+)\)').astype(float)

    # Create a scatter trace
    scatter_trace = go.Scatter(
        x=df['Longitude'],
        y=df['Latitude'],
        text=df['wlbWellboreName'],  # Use the 'wlbWellboreName' column for text labels
        mode='markers', #+text
        name = "Injection wells",
        #hoverinfo=df['wlbContentPlanned'],
        marker=dict(size=10, color='blue', symbol='circle'),
    )

    # Add the scatter trace to the provided figure
    fig.add_trace(scatter_trace)

    # Update layout properties (optional)
    fig.update_layout(
        title='Reservoir and well locations ' + str(field),
        xaxis_title='Longitude',
        yaxis_title='Latitude',
    )

    return fig
    
def makePlot(field):
    fig = go.Figure()
    import Data.getData as get
    wkt_str = get.polygon_coordinates(field)
    polygon_plotter = PolygonPlotter(wkt_str)
    col1, col2, col3, col4 = st.columns(4)

    with col2:
        updated_fig = wlb_plot_production(polygon_plotter.fig, get.producing_wlb(field), field)
        updated_fig = wlb_plot_injection(polygon_plotter.fig, get.injecting_wlb(field), field)   
        st.plotly_chart(updated_fig)
   


# File: .\Modules\NPD_DATA\__init__.py



# File: .\Modules\RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA\dry_gas_R_analysis.py
import pandas as pd
import pandas as pd
import numpy as np
from Equations.ZfacStanding import ZfacStanding
from Equations.MBgastank_PR import MBgastank_PR
from Equations.RF import RF

def ResAnalysis(produced:list, parameters:list):
    df = build_analysis(produced, *parameters) 
    df.columns=('PR', 'cumulative produced gas [sm3]', 'produced gas [sm3]')
    return df

def build_analysis(produced:list, PRi: float, TR:float, gasMolecularWeight: float, IGIP) -> float: 
    sim_len = len(produced)
    df = pd.DataFrame(np.zeros((sim_len, 3)))
    Zi = ZfacStanding(PRi, TR, gasMolecularWeight)
    df[0][0:sim_len] = produced #assign column one to what has been produced.
    df[1][0] = produced[0] 
    for i in range(sim_len):
        df[1][i] = df.iloc[i, 0] + df.iloc[i-1, 1]
    from scipy.optimize import fsolve
    def swapColumns(df, col1, col2):
        col_list = list(df.columns)
        x, y = col_list.index(col1), col_list.index(col2)
        col_list[y], col_list[x] = col_list[x], col_list[y]
        df = df[col_list]
        return df
    def f(X):                             
        return X - MBgastank_PR(PRi, Zi, ZfacStanding(X, TR, gasMolecularWeight), RF(df.iloc[i, 1],IGIP)) 
    for i in range(sim_len):
        if i == 0:
            df[2][0] = fsolve(f, PRi)
        else:
            df[2][i] = fsolve(f, df.iloc[i-1,2])    
    df = swapColumns(df, 0, 2)
    return df




# File: .\Modules\RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA\run_R_analysis.py
import pandas as pd
from Data.Storage.Cache import SessionState
import GUI.GUI_functions as display
import streamlit as st
from GUI.GUI_class import RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA
import Data.getData as get
class ReservoirPressureAnalysis(RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA):
    def __init__(self, parent, session_id:str, field:str = 'No field chosen', time: str = 'Yearly'):
        self.__production_data = []
        self.__field = field
        self.__time_frame = time
        self.__result = []
        self.__session_id = session_id
        self.__parameters = []
        self.edible_df = None
        self.__state = SessionState.get(id=session_id, result=[], time_frame=[], field=[], production_data=[], parameters = [])

    def updateFromDropDown(self, fieldName, time):
         self.__field, self.__time_frame = fieldName, time
    
    def update_from_upload(self, productionData):
        self.__production_data = productionData
    
    def updateParameterListfromTable(self, list2):
        list1 = ['Initial Reservoir Pressure [bara]', 'Reservoir Temperature [degree C]', 'Gas Molecular Weight [g/mol]', 'Initial Gas in Place [sm3]']
        self.__parameters = (display.display_table_RESPRES(list1=list1, list2=list2, edible=True))



    def get__PR_NPD_data(self):
        PRi = get.initial_reservoir_pressure(self.__field)
        T_R = get.Temp(self.__field)        
        gasMolecularWeight = get.gas_molecular_weight(self.__field)
        IGIP = get.IGIP(self.__field)
        return PRi, T_R, gasMolecularWeight, IGIP

    def runY(self):
        self.append_field(self.__field)
        self.append_time_frame(self.__time_frame)
        self.append_parameters(self.__parameters)
        from Modules.RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA.dry_gas_R_analysis import ResAnalysis
        gas = get.CSVProductionYearly(self.__field)[0]
        gas = [i*10**9 for i in gas] #prfPrdGasNetBillSm3
        import Data.dataProcessing as dP
        df = ResAnalysis(gas, self.__parameters)
        import Data.dataProcessing as dP
        df = dP.yearly_produced_DF(self.__field, df)
        df = dP.addProducedYears(self.__field, df)
        return df
    
    def run_uploaded(self):
        self.append_field(self.__field)
        self.append_time_frame(self.__time_frame)
        self.append_parameters(self.__parameters)
        from Modules.RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA.dry_gas_R_analysis import ResAnalysis
        uploaded = self.get_current_production_data()
        self.__field = "No field chosen"
        if uploaded.type == "text/csv":
            try:
                data = pd.read_csv(uploaded, sep=";", skip_blank_lines=True)
                data = data.dropna(how='all')
                gas = data.iloc[:,0].to_list()
                df = ResAnalysis(gas, self.__parameters)
                df.index = df.iloc[:,1].to_list()
                return df
            except:
                (st.warning("an error occured with uploaded file, try a new file"))
        else:
            import time as ti
            alert10 = st.warning("You have not uploaded a CSV file")
            ti.sleep(3)
            alert10.empty()

    
    def runM(self):
        self.append_field(self.__field)
        self.append_time_frame(self.__time_frame)
        self.append_parameters(self.__parameters)
        gas = get.CSVProductionMonthly(self.__field)[0]
        gas = [i*10**9 for i in gas] #prfPrdGasNetBillSm3    
        import Data.dataProcessing as dP
        from Modules.RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA.dry_gas_R_analysis import ResAnalysis
        df = ResAnalysis(gas, self.__parameters)
        import Data.dataProcessing as dP
        df = dP.monthly_produced_DF(self.__field, df )
        df = dP.addProducedMonths(self.__field, df)
        return df
    

    def plot(self, comp=False):
        import streamlit as st
        from pandas import DataFrame
        res = self.getResult()
        field = self.getField()
        if comp == False:
            for i in range(len(res)):
                if isinstance(res[i], DataFrame):
                    header_ = 'Est Res-pressure ' + str(i+1)
                    st.header(header_, divider='red')
                    if field[i] != "No field chosen":
                        st.write(field[i][0]+field[i][1:].lower())
                        st.write("$P_R$ = " + str(self.getParameters()[i][0]) + " Bar")
                        st.write("T = " + str(self.getParameters()[i][1]) + " $^{\circ}$C")
                        st.write("Gas Molecular Wieght = " + str(self.getParameters()[i][2]) + " g/mol")
                        st.write("IGIP = " + str((self.getParameters()[i][3]/1e9)) + " billion $sm^3$")

                    else:
                        st.write('Uploaded data')
                        st.write("$P_R$ = " + str(self.getParameters()[i][0]) + " Bar")
                        st.write("T = " + str(self.getParameters()[i][1]) + " $^{\circ}$C")
                        st.write("Gas Molecular Wieght = " + str(self.getParameters()[i][2]) + " g/mol")
                        st.write("IGIP = " + str((self.getParameters()[i][3]/1e9)) + " billion $sm^3$")
                    display.multi_plot_PR([res[i]], addAll= False)
        else:
            dfs = []
            for df in self.__state.result:
                reset_ind_df = df.reset_index(drop = True)
                dfs.append(reset_ind_df)
            display.multi_plot(dfs, addAll=False)

    def clear_output(self):
        from Data.Storage.Cache import SessionState
        SessionState.delete(id = self.__session_id)
        self.__state = SessionState.get(id=self.__session_id, result=[], time_frame=[], field=[], production_data=[], parameters = [])
    
    
    def get_current_time_frame(self):
        return self.__time_frame
    def get_current_field(self):
        return self.__field
    def get_current_result(self):
        return self.__result
    def get_current_parameters(self):
        return self.__parameters
    def get_current_production_data(self):
        return self.__production_data

    def getResult(self) -> list:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'result', [])

    def get_time_frame(self) -> pd.DataFrame:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'time_frame', pd.DataFrame())
    
    def getField(self) -> pd.DataFrame:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'field', pd.DataFrame())
    
    def getParameters(self) -> pd.DataFrame:
        session_state = self.__state.get(self.__session_id)
        return getattr(session_state, 'parameters', pd.DataFrame())

    def getState(self) -> SessionState:
        session_state = self.__state.get(self.__session_id)
        return session_state
    
    def delParameters(self):
        del self.__parameters
    
    
    def append_time_frame(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'time_frame', value = item)

    def append_result(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'result', value = item)
    
    def append_field(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'field', value = item)
        
    def append_parameters(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'parameters', value = item)
    
    def append_production_data(self, item) -> str:
        SessionState.append(id = self.__session_id, key = 'production_data', value = item)

    def get_edible_df(self):
        return self.__edible_df
    
    def update_edible_df(self, list2):
        self.__edible_df.update_table(list2)
        #self.__edible_df = display.edible_df(list2)
        #self.__parameters =self.__edible_df.get_parameters()
        #self.__edible_df = self.__edible_df, self.__parameters = (display.display_table_RESPRES(list1=list1, list2=list2, edible=True))


# File: .\Modules\RESERVOIR_PRESSURE_FROM_PRODUCTION_DATA\__init__.py



# File: .\Modules\xtra\datasetToDict.py
import dataiku
def datasetToDict(inputDataSet):
    
    """
    Reads input dataset and stores data as dictionary that can be used for IPR and Nodal analysis. 
    The input dataset should be ordered as following:
    
    
    variableName1       variableName2       variableName3       ...           variableNameN
     
    value1              value2              value3              ...           valueN

    
    
    """
    data = dataiku.Dataset(inputDataSet)
    data_df = data.get_dataframe()
    dataDict = data_df.to_dict("list")
    return dataDict



# File: .\Modules\xtra\dictToFunc.py
from Data.datasetToDict import datasetToDict
def dictToFunc(inputDataSet):
    dataDict = datasetToDict(inputDataSet)   
    qFieldTarget = dataDict.get('qFieldTarget')[0]
    PRi = dataDict.get('PRi')[0]
    abandonmentRate = dataDict.get('abandonmentRate')[0]
    TR = dataDict.get('TR')[0]
    gasMolecularWeight = dataDict.get('gasMolecularWeight')[0]
    C_R = dataDict.get('C_R')[0]
    n = dataDict.get('n')[0]
    N_temp = dataDict.get('N_temp')[0]
    NWellsPerTemplate = dataDict.get('NWellsPerTemplate')[0]
    upTime = dataDict.get('upTime')[0]
    C_t = dataDict.get('C_t')[0]
    S = dataDict.get('S')[0]
    C_FL = dataDict.get('C_FL')[0]
    C_PL = dataDict.get('C_PL')[0]
    P_sep = dataDict.get('P_sep')[0]
    IGIP = dataDict.get('IGIP')[0]
    
    
    return [qFieldTarget, PRi, abandonmentRate, TR, gasMolecularWeight, C_R, n, N_temp, NWellsPerTemplate, upTime, C_t, S, C_FL, C_PL, P_sep, IGIP]
    



# File: .\Modules\xtra\DryGasNetworks\chokePressure.py



# File: .\Modules\xtra\DryGasNetworks\chokeRate.py



# File: .\Modules\xtra\DryGasNetworks\noChoke.py
import pandas as pd
import numpy as np
import Equations.DryGasFlowEquations as DGFE
from scipy.optimize import minimize
import warnings
#Network of two gas fields
#PR1 = 90
#PR2 = 160
#C_R1 = 52
#C_R2 = 40
#n1 = 0.8
#n2 = 0.75
#S1 = 0.13
#S2 = 0.11
#C_t1 = 7680
#C_t2 = 8600
#C_W1 = 8673
#C_W2 = 7563
#C_PIPELINE = 14080
#Psep = 28.6


def noChoke(PR1, PR2, C_R1, C_R2, n1, n2, S1, S2, C_t1, C_t2, C_W1, C_W2, C_PIPELINE, Psep):  
    #for storing the network data in the dataframe 
    def Network(PR1, PR2, C_R1, C_R2, n1, n2, S1, S2, C_t1, C_t2, C_W1, C_W2, C_PIPELINE, Psep): 
        df = pd.DataFrame(np.zeros((3, 12))) 
        #df[0][0:2] = PR
        df[0][0] = PR1
        df[0][1] = PR2
        df[1][0] = C_R1
        df[1][1] = C_R2
        df[2][0] = n1
        df[2][1] = n2
        df[3][0] = S1
        df[3][1] = S2
        df[4][0] = C_t1
        df[4][1] = C_t2
        df[5][0] = C_W1
        df[5][1] = C_W2
        df[5][2] = C_PIPELINE
        df[6][2] = Psep    
        return df

    def error(params, df): #for finding the optimal production volumes from each well we minimize the error by changing the bottomhole pressure for each well
        Pwf1, Pwf2 = params
        df[7][0] = Pwf1 #guess for bottomhole pressure well one
        df[7][1] = Pwf2 #guess for bottomhole pressure well two
        df[8][0] = DGFE.IPRqg(C_R1, n1, PR1, df.iloc[0, 7]) #q_well one
        df[8][1] = DGFE.IPRqg(C_R2, n2, PR2, df.iloc[1, 7]) #q_well two
        df[8][2] = df.iloc[0, 8] + df.iloc[1, 8] #q_total 
        df[9][0] = DGFE.Tubingp2(C_t1, S1, df.iloc[0, 7], df.iloc[0, 8]) #pressure at wellhead 1
        df[9][1] = DGFE.Tubingp2(C_t2, S2, df.iloc[1, 7], df.iloc[1, 8]) #pressure at wellhead 2
        df[10][0] = DGFE.Linep2(C_W1, df.iloc[0, 9], df.iloc[0, 8]) #pressure at junction
        df[10][1] = DGFE.Linep2(C_W2, df.iloc[1, 9], df.iloc[1, 8]) #pressure at junction
        df[10][2] = DGFE.Linep1(C_PIPELINE, Psep, df.iloc[2, 8]) #pressure at other side of junction
        Average = (df.iloc[0, 10]+df.iloc[1, 10]+df.iloc[2, 10])/3
        df[11][0] = (Average-df.iloc[0, 10])**2 #square error
        df[11][1] = (Average-df.iloc[1, 10])**2 #square error
        df[11][2] = (Average-df.iloc[2, 10])**2 #square errror
        return (df.iloc[0, 11] + df.iloc[1, 11] + df.iloc[2, 11]) #sum of square errors, which we want to minimize to find our solution
    initial_guess = [1, 1] #our initial guess 
    df = Network(PR1, PR2, C_R1, C_R2, n1, n2, S1, S2, C_t1, C_t2, C_W1, C_W2, C_PIPELINE, Psep)    
     #ignoring warning that occurs due to initial guess leading to no solution
    warnings.filterwarnings("ignore")
    result = minimize(error, initial_guess, df)

    i = 1
    while (result.success == False and i<PR1*3): #updating our initial guess 
                                                #no need to check for solutions for unlikely bottomhole pressures
        i+=2
        initial_guess =  [i, i]
        result = minimize(error, initial_guess, df)
    if result.success:
        fitted_params = result.x
        #print(fitted_params)
        print(df.iloc[0, 8], "sm3/d from well 1 and", df.iloc[1, 8], "sm3/d from well 2.")
        return df
    else:
        raise ValueError('No solution found. Try guessing Pwf manually.') #no solution found



# File: .\Modules\xtra\DryGasNetworks\__init__.py



# File: .\Modules\xtra\reservoirModel\reservoirModel.py
import pandas as pd 
import numpy as np
import matplotlib.pyplot as plt
import time
start_time=time.time()
perm1=1e-13 #Permeability constants
perm2=1e-17
perm3=2e-14
mu=1e-3 #Viscosity
poro=0.2 #porosity
c_t=1e-9 #total compressibiliy [1/Pa]
p_r=2e+7 #initial pressure [Mpa]
p_w=1e+7 #Well pressure [Mpa]

    
#calculations 

dx=1 #steplength 
dy=1
dt=1/2 #timelength set to half a second
h=50 #reservoir height [m]
l=200 #reservoir length [m]

#creating the permeability matrix
k=pd.DataFrame(np.zeros((h, l)))  
k[0:20]=perm1 #Adding correct permeability to the layers
k[20:30]=perm2
k[30:50]=perm3

#creating initial pressure distribution matrix [t=0]
def initialize(): 
    p=pd.DataFrame(np.zeros((h, l))) #Pandas dataframe
    p[p.columns[0:200]]=p_r #initial pressure
    p[0][0:20]=p_w #boundary condition
    p[0][30:50]=p_w #boundary condition
    return p
flowlist=[]
#update flow gradient in horizontal direction 
def update_gradient(p):
    #Manipulating matrices
    p2=p[p.columns[1:200]] #p shifted dx
    p2 = p2.T.reset_index(drop=True).T #Resetting index, (needed to transpose since reset index resets rows)
    p2.insert(loc=199, column=199, value=p[199]) #Adding end point value for forward difference

    #Calculating Pressure gradient:
    p_der_x=(p2-p)/dx #Forward finite difference method

    #Calculating flow and manipulating matrices:
    qx=p_der_x*(-k)/mu #Flow in horizontal direction
    update_gradient.variable=qx #Saving flow as variable
    qx2=qx[qx.columns[1:200]] #p shifted dx
    qx2 = qx2.T.reset_index(drop=True).T #Resetting index, 
    df = pd.DataFrame([0 for _ in range(50)]) #A column of zeros
    qx2.insert(loc=199, column=199, value=df) #Inserting zero to end ponint for boundary condition
    qx2 = qx2.T.reset_index(drop=True).T 

    #Calculating flow gradient:
    qx_der_x=(qx2-qx)/dx #Backward finite difference method
    qx_der_x.insert(loc=0, column=-1, value=df) #Inserting 0 for correct backward difference
    qx_der_x = qx_der_x.T.reset_index(drop=True).T
    qx_der_x=qx_der_x[qx_der_x.columns[0:200]] #Shifting the matrix for correct calculation

    Q = -qx[0].sum()
    flowlist.append(Q)
    #update_gradient.variable=flowlist
    return qx_der_x

#update flow gradient in vertical direction
def update_gradient2(p):
    #Manipulating matrices:
    py2=(p[1:50]).reset_index(drop=True)
    py2=py2.append(p[49:50]) #Adding end point value for forward difference

    #Calculating pressure gradient
    p_der_y=(py2-p)/dy #Forward difference method

    #Calculating flow and manipulating matrices:
    qy=p_der_y*-k/mu #Flow in vertical direction
    update_gradient2.variable=qy #saving flow as variable
    qy2=qy[1:50] #qy shifted dy
    qy2=qy2.reset_index(drop=True) 
    df = pd.DataFrame(np.zeros((1, 200)))#Zero matrix
    qy2=qy2.append(df) #Adding zero for boundary condidion
    qy2=qy2.reset_index(drop=True)

    #Calculating flow gradient:
    qx_der_y=(qy2-qy)/dy #Backward difference 
    qx_der_y=df.append(qx_der_y) #Adding zero for boundary condition
    qx_der_y = qx_der_y.reset_index(drop=True)
    qx_der_y=qx_der_y[0:50] #Shifting matrix for correct backward difference
    return qx_der_y

#Calculate pressure distribution matrix at time t [s]
def calculate_pressure(t):
    p=initialize()
    for i in range(1,t+1):
        qx_der_x=update_gradient(p) #Fetching dq/dx
        qx_der_y=update_gradient2(p) #Fetching dq/dy

        p+=-dt/(poro*c_t)*(qx_der_x+qx_der_y) #Main equation
    return p

# def calculate_flow(t):
#     for i in range(1,t+1): 
#         qx = update_gradient.variable
#         #print(qx)
#         Q = -qx.sum(columns(0))
#         #print(Q)
#     return Q 

#plotting the pressure distribution matrix at time t [s]
def plot_pressure(t):

    p=calculate_pressure(t)
    p = p.reindex(index=p.index[::-1]) #need to reverse rows for plotting
    plt.imshow(p, origin="lower", cmap="jet", extent = (0, 200, 50, 0), aspect=3)
    plt.xlabel('Distance from well [m]')
    plt.ylabel('Depth [m]')
    plt.title('Pressure [MPa], Time: '+ str(t/(3600*2)) + ' hour(s)')
    cbar = plt.colorbar()
    #cbar.set_ticks(['10', '11','12','13','14','15','16','17','18','19','20'])

    #For plotting flow arrays
    U=update_gradient.variable #Fetching horizontal flow
    V=update_gradient2.variable #Fetching vertical flow
    U=U.iloc[:, ::20] #Point every ten meters in x-direction
    U=U.iloc[::4, :] #Point every four meters in y-direction
    V=V.iloc[:, ::20]
    V=V.iloc[::4, :]
    x,y = np.meshgrid(np.arange(0,200,20),np.arange(0,50,4)) #Creating grid for vectors 
    plt.quiver(x,y, U, -V, width=0.002, headwidth=4, scale=None) #Plotting vectors and rescaling
    plt.show()

    #Flow into the well
def plot_flow(t):  
    t=np.linspace(0, t*1/2, t)
    Q=np.array(flowlist)
    plt.plot(t, Q)
    plt.yscale('log',base = 10)
    plt.xscale('log',base = 10)
    plt.grid()
    plt.title('Flow into the well ')
    plt.xlabel('Time [s]')
    plt.ylabel('Flow [m3/s]')
    plt.show()

def run(t):
    plot_pressure(t*3600*2)

    #calling on the plot pressure function as a function of the calculated pressure at time t.
    #because dt is 0.5, we need to double the time
    #In this partical case 1 hour is the chosen simulation time
     #calculate_pressure(3600*2*24*4)
     #print(time.time()-start_time) #Prints running time
     #plot_flow(3600*2*24*4) #plotting log-log flow vs time 4 days
      #print(sum(flowlist)) #cumulative produciton 


# File: .\Modules\xtra\reservoirModel\__init__.py


